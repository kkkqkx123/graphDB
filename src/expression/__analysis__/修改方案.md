# 修改方案

## 概述

本文档提供了针对 `src\expression` 目录中简化实现的详细修改方案，包括具体的实现步骤、代码示例和测试建议。

## 1. LIKE 操作实现方案

### 目标

实现完整的 SQL LIKE 操作，支持通配符 `%` 和 `_`，以及自定义转义字符。

### 实现步骤

#### 步骤 1: 在 `operations.rs` 中实现 LIKE 操作

**文件**: `src/expression/evaluator/operations.rs`

```rust
fn eval_like(left: &Value, right: &Value) -> Result<Value, ExpressionError> {
    // 检查是否为 BadNull
    if left.is_bad_null() || right.is_bad_null() {
        return Ok(Value::NullBadType);
    }
    
    // 检查类型
    if (!left.is_null() && !left.is_empty() && !left.is_string()) ||
       (!right.is_null() && !right.is_empty() && !right.is_string()) {
        return Ok(Value::NullBadType);
    }
    
    // 如果任一为 NULL（非 BadNull），返回 NULL
    if left.is_null() || right.is_null() {
        return Ok(Value::Null);
    }
    
    // 执行 LIKE 匹配
    let value = left.as_string().unwrap();
    let pattern = right.as_string().unwrap();
    
    match Self::like_match(&value, &pattern, None) {
        Ok(result) => Ok(Value::Bool(result)),
        Err(e) => {
            log::error!("LIKE 匹配错误: {}", e);
            Ok(Value::NullBadType)
        }
    }
}

/// LIKE 模式匹配
fn like_match(value: &str, pattern: &str, escape_char: Option<char>) -> Result<bool, String> {
    let mut pattern_chars = pattern.chars().peekable();
    let mut value_chars = value.chars().peekable();
    
    let escape = escape_char.unwrap_or('\\');
    
    while let Some(p) = pattern_chars.next() {
        match p {
            '%' => {
                // 匹配任意字符序列（包括空序列）
                if pattern_chars.peek().is_none() {
                    return Ok(true);
                }
                
                // 尝试匹配剩余模式
                let remaining_pattern: String = pattern_chars.collect();
                let remaining_value: String = value_chars.collect();
                
                for i in 0..=remaining_value.len() {
                    if Self::like_match(&remaining_value[i..], &remaining_pattern, escape_char)? {
                        return Ok(true);
                    }
                }
                
                return Ok(false);
            }
            '_' => {
                // 匹配任意单个字符
                if value_chars.next().is_none() {
                    return Ok(false);
                }
            }
            c if c == escape => {
                // 转义字符，下一个字符按字面量处理
                if let Some(next_char) = pattern_chars.next() {
                    if value_chars.next() != Some(next_char) {
                        return Ok(false);
                    }
                } else {
                    return Err("转义字符后没有字符".to_string());
                }
            }
            c => {
                // 字面量匹配
                if value_chars.next() != Some(c) {
                    return Ok(false);
                }
            }
        }
    }
    
    // 模式已匹配完毕，值也必须匹配完毕
    Ok(value_chars.peek().is_none())
}
```

#### 步骤 2: 添加单元测试

**文件**: `src/expression/evaluator/tests/like_test.rs`

```rust
use crate::core::value::types::Value;
use crate::expression::evaluator::operations::BinaryOperationEvaluator;

#[test]
fn test_like_simple() {
    let value = Value::String("hello".to_string());
    let pattern = Value::String("hello".to_string());
    
    let result = BinaryOperationEvaluator::eval_like(&value, &pattern).unwrap();
    assert_eq!(result, Value::Bool(true));
}

#[test]
fn test_like_percent_wildcard() {
    let value = Value::String("hello world".to_string());
    let pattern = Value::String("hello%".to_string());
    
    let result = BinaryOperationEvaluator::eval_like(&value, &pattern).unwrap();
    assert_eq!(result, Value::Bool(true));
}

#[test]
fn test_like_underscore_wildcard() {
    let value = Value::String("hello".to_string());
    let pattern = Value::String("h_llo".to_string());
    
    let result = BinaryOperationEvaluator::eval_like(&value, &pattern).unwrap();
    assert_eq!(result, Value::Bool(true));
}

#[test]
fn test_like_null() {
    let value = Value::String("hello".to_string());
    let pattern = Value::Null;
    
    let result = BinaryOperationEvaluator::eval_like(&value, &pattern).unwrap();
    assert_eq!(result, Value::Null);
}

#[test]
fn test_like_escape() {
    let value = Value::String("100%".to_string());
    let pattern = Value::String("100\\%".to_string());
    
    let result = BinaryOperationEvaluator::like_match("100%", "100\\%", Some('\\')).unwrap();
    assert!(result);
}
```

### 优先级

**高优先级** - 关键功能缺失，需要立即实现

## 2. Date 转换修复方案

### 目标

修复 Date 转换的简化实现，使用正确的日期计算逻辑，支持闰年和不同月份的天数。

### 实现步骤

#### 步骤 1: 添加日期计算辅助函数

**文件**: `src/expression/storage/date_utils.rs` (新建)

```rust
/// 月份天数表（非闰年）
const DAYS_IN_MONTH: [u32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

/// 累计天数表（非闰年）
const DAYS_SO_FAR: [i64; 13] = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

/// 累计天数表（闰年）
const LEAP_DAYS_SO_FAR: [i64; 13] = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];

/// 判断是否为闰年
pub fn is_leap_year(year: i32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

/// 获取某年某月的天数
pub fn days_in_month(year: i32, month: u32) -> u32 {
    if month == 2 && is_leap_year(year) {
        29
    } else {
        DAYS_IN_MONTH[(month - 1) as usize]
    }
}

/// 将天数转换为日期（从 1970-01-01 开始）
pub fn days_to_date(days: i64) -> (i32, u32, u32) {
    // Unix 时间戳从 1970-01-01 开始
    let epoch_year = 1970;
    
    // 计算年份
    let mut year = epoch_year;
    let mut remaining_days = days;
    
    while remaining_days >= 365 {
        let days_in_year = if is_leap_year(year) { 366 } else { 365 };
        if remaining_days >= days_in_year {
            remaining_days -= days_in_year;
            year += 1;
        } else {
            break;
        }
    }
    
    // 计算月份和日期
    let month_days = if is_leap_year(year) {
        &LEAP_DAYS_SO_FAR
    } else {
        &DAYS_SO_FAR
    };
    
    let mut month = 1;
    for m in 1..=12 {
        if remaining_days < month_days[m as usize] {
            month = m;
            break;
        }
    }
    
    let day = (remaining_days - month_days[(month - 1) as usize] + 1) as u32;
    
    (year, month, day)
}

/// 将日期转换为天数（从 1970-01-01 开始）
pub fn date_to_days(year: i32, month: u32, day: u32) -> i64 {
    let epoch_year = 1970;
    let mut days = 0i64;
    
    // 计算年份天数
    for y in epoch_year..year {
        days += if is_leap_year(y) { 366 } else { 365 };
    }
    
    // 计算月份天数
    let month_days = if is_leap_year(year) {
        &LEAP_DAYS_SO_FAR
    } else {
        &DAYS_SO_FAR
    };
    
    days += month_days[(month - 1) as usize];
    days += day as i64 - 1;
    
    days
}
```

#### 步骤 2: 修改 row_reader.rs 中的日期转换

**文件**: `src/expression/storage/row_reader.rs`

```rust
use super::date_utils::{days_to_date, date_to_days};

// 修改 read_date 方法
fn read_date(&self, column_name: &str) -> Result<Value, StorageError> {
    let days = self.read_i64(column_name)?;
    
    let (year, month, day) = days_to_date(days);
    
    Ok(Value::Date(crate::core::value::DateValue {
        year,
        month,
        day,
    }))
}
```

#### 步骤 3: 添加单元测试

**文件**: `src/expression/storage/tests/date_test.rs`

```rust
use super::super::date_utils::{days_to_date, date_to_days, is_leap_year, days_in_month};

#[test]
fn test_is_leap_year() {
    assert!(is_leap_year(2000));
    assert!(is_leap_year(2020));
    assert!(!is_leap_year(1900));
    assert!(!is_leap_year(2021));
}

#[test]
fn test_days_in_month() {
    assert_eq!(days_in_month(2020, 2), 29); // 闰年二月
    assert_eq!(days_in_month(2021, 2), 28); // 非闰年二月
    assert_eq!(days_in_month(2021, 1), 31);
    assert_eq!(days_in_month(2021, 4), 30);
}

#[test]
fn test_days_to_date_epoch() {
    let (year, month, day) = days_to_date(0);
    assert_eq!((year, month, day), (1970, 1, 1));
}

#[test]
fn test_days_to_date_one_year() {
    let (year, month, day) = days_to_date(365);
    assert_eq!((year, month, day), (1971, 1, 1));
}

#[test]
fn test_days_to_date_leap_year() {
    let (year, month, day) = days_to_date(366);
    assert_eq!((year, month, day), (1971, 1, 2));
}

#[test]
fn test_date_to_days_epoch() {
    let days = date_to_days(1970, 1, 1);
    assert_eq!(days, 0);
}

#[test]
fn test_date_to_days_roundtrip() {
    let original_days = 10000;
    let (year, month, day) = days_to_date(original_days);
    let converted_days = date_to_days(year, month, day);
    assert_eq!(original_days, converted_days);
}
```

### 优先级

**高优先级** - 数据准确性问题，需要立即修复

## 3. DateTime 转换修复方案

### 目标

修复 DateTime 转换的简化实现，使用时间戳计算完整的日期时间。

### 实现步骤

#### 步骤 1: 添加时间戳转换函数

**文件**: `src/expression/storage/date_utils.rs`

```rust
/// 将时间戳转换为 DateTime
pub fn timestamp_to_datetime(timestamp: i64) -> (i32, u32, u32, u8, u8, u8, u32) {
    // 分离日期和时间部分
    let days = timestamp / 86400; // 秒转天
    let seconds_in_day = timestamp % 86400;
    
    // 计算日期
    let (year, month, day) = days_to_date(days);
    
    // 计算时间
    let hour = (seconds_in_day / 3600) as u8;
    let minute = ((seconds_in_day % 3600) / 60) as u8;
    let second = (seconds_in_day % 60) as u8;
    let microsecond = 0;
    
    (year, month, day, hour, minute, second, microsecond)
}

/// 将 DateTime 转换为时间戳
pub fn datetime_to_timestamp(
    year: i32,
    month: u32,
    day: u32,
    hour: u8,
    minute: u8,
    second: u8,
    microsecond: u32,
) -> i64 {
    let days = date_to_days(year, month, day);
    let seconds = days * 86400 + hour as i64 * 3600 + minute as i64 * 60 + second as i64;
    seconds
}
```

#### 步骤 2: 修改 row_reader.rs 中的 DateTime 转换

**文件**: `src/expression/storage/row_reader.rs`

```rust
use super::date_utils::{timestamp_to_datetime, datetime_to_timestamp};

// 修改 read_datetime 方法
fn read_datetime(&self, column_name: &str) -> Result<Value, StorageError> {
    let timestamp = self.read_i64(column_name)?;
    
    let (year, month, day, hour, minute, second, microsecond) = timestamp_to_datetime(timestamp);
    
    Ok(Value::DateTime(crate::core::value::DateTimeValue {
        date: crate::core::value::DateValue {
            year,
            month,
            day,
        },
        time: crate::core::value::TimeValue {
            hour,
            minute,
            second,
            microsecond,
        },
    }))
}
```

#### 步骤 3: 添加单元测试

**文件**: `src/expression/storage/tests/datetime_test.rs`

```rust
use super::super::date_utils::{timestamp_to_datetime, datetime_to_timestamp};

#[test]
fn test_timestamp_to_datetime_epoch() {
    let (year, month, day, hour, minute, second, microsecond) = timestamp_to_datetime(0);
    assert_eq!((year, month, day, hour, minute, second, microsecond), (1970, 1, 1, 0, 0, 0, 0));
}

#[test]
fn test_timestamp_to_datetime_one_hour() {
    let (year, month, day, hour, minute, second, microsecond) = timestamp_to_datetime(3600);
    assert_eq!((year, month, day, hour, minute, second, microsecond), (1970, 1, 1, 1, 0, 0, 0));
}

#[test]
fn test_timestamp_to_datetime_one_day() {
    let (year, month, day, hour, minute, second, microsecond) = timestamp_to_datetime(86400);
    assert_eq!((year, month, day, hour, minute, second, microsecond), (1971, 1, 1, 0, 0, 0, 0));
}

#[test]
fn test_datetime_to_timestamp_epoch() {
    let timestamp = datetime_to_timestamp(1970, 1, 1, 0, 0, 0, 0);
    assert_eq!(timestamp, 0);
}

#[test]
fn test_datetime_to_timestamp_roundtrip() {
    let original_timestamp = 1234567890;
    let (year, month, day, hour, minute, second, microsecond) = timestamp_to_datetime(original_timestamp);
    let converted_timestamp = datetime_to_timestamp(year, month, day, hour, minute, second, microsecond);
    assert_eq!(original_timestamp, converted_timestamp);
}
```

### 优先级

**高优先级** - 数据准确性问题，需要立即修复

## 4. ColumnDef 类型定义改进方案

### 目标

将 ColumnDef 的 data_type 字段从 String 改为枚举类型，提高类型安全性。

### 实现步骤

#### 步骤 1: 定义 FieldType 枚举

**文件**: `src/expression/storage/types.rs`

```rust
/// 字段类型枚举
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum FieldType {
    Bool,
    Int,
    Float,
    String,
    Date,
    Time,
    DateTime,
    Vertex,
    Edge,
    Path,
    List,
    Map,
    Set,
    DataSet,
    Geography,
    Duration,
    Null,
}

impl FieldType {
    /// 获取类型的字符串表示
    pub fn as_str(&self) -> &'static str {
        match self {
            FieldType::Bool => "bool",
            FieldType::Int => "int",
            FieldType::Float => "float",
            FieldType::String => "string",
            FieldType::Date => "date",
            FieldType::Time => "time",
            FieldType::DateTime => "datetime",
            FieldType::Vertex => "vertex",
            FieldType::Edge => "edge",
            FieldType::Path => "path",
            FieldType::List => "list",
            FieldType::Map => "map",
            FieldType::Set => "set",
            FieldType::DataSet => "dataset",
            FieldType::Geography => "geography",
            FieldType::Duration => "duration",
            FieldType::Null => "null",
        }
    }
    
    /// 从字符串解析类型
    pub fn from_str(s: &str) -> Result<Self, String> {
        match s.to_lowercase().as_str() {
            "bool" | "boolean" => Ok(FieldType::Bool),
            "int" | "integer" => Ok(FieldType::Int),
            "float" | "double" => Ok(FieldType::Float),
            "string" | "str" => Ok(FieldType::String),
            "date" => Ok(FieldType::Date),
            "time" => Ok(FieldType::Time),
            "datetime" => Ok(FieldType::DateTime),
            "vertex" => Ok(FieldType::Vertex),
            "edge" => Ok(FieldType::Edge),
            "path" => Ok(FieldType::Path),
            "list" => Ok(FieldType::List),
            "map" => Ok(FieldType::Map),
            "set" => Ok(FieldType::Set),
            "dataset" => Ok(FieldType::DataSet),
            "geography" => Ok(FieldType::Geography),
            "duration" => Ok(FieldType::Duration),
            "null" => Ok(FieldType::Null),
            _ => Err(format!("未知的数据类型: {}", s)),
        }
    }
}

impl std::fmt::Display for FieldType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

impl std::str::FromStr for FieldType {
    type Err = String;
    
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::from_str(s)
    }
}

/// 列定义
#[derive(Debug, Clone)]
pub struct ColumnDef {
    pub name: String,
    pub data_type: FieldType,
    pub nullable: bool,
}

impl ColumnDef {
    pub fn new(name: impl Into<String>, data_type: FieldType, nullable: bool) -> Self {
        Self {
            name: name.into(),
            data_type,
            nullable,
        }
    }
}
```

#### 步骤 2: 更新所有使用 ColumnDef 的代码

需要更新以下文件：
- `src/expression/storage/schema_def.rs`
- `src/expression/storage/row_reader.rs`
- 其他使用 ColumnDef 的文件

**示例更新**:

```rust
// 之前
let column = ColumnDef {
    name: "id".to_string(),
    data_type: "int".to_string(),
    nullable: false,
};

// 之后
let column = ColumnDef::new("id", FieldType::Int, false);
```

#### 步骤 3: 添加单元测试

**文件**: `src/expression/storage/tests/types_test.rs`

```rust
use super::super::types::{FieldType, ColumnDef};

#[test]
fn test_field_type_from_str() {
    assert_eq!(FieldType::from_str("int").unwrap(), FieldType::Int);
    assert_eq!(FieldType::from_str("INT").unwrap(), FieldType::Int);
    assert_eq!(FieldType::from_str("string").unwrap(), FieldType::String);
    assert!(FieldType::from_str("unknown").is_err());
}

#[test]
fn test_field_type_display() {
    assert_eq!(format!("{}", FieldType::Int), "int");
    assert_eq!(format!("{}", FieldType::String), "string");
}

#[test]
fn test_column_def_new() {
    let column = ColumnDef::new("id", FieldType::Int, false);
    assert_eq!(column.name, "id");
    assert_eq!(column.data_type, FieldType::Int);
    assert_eq!(column.nullable, false);
}
```

### 优先级

**中优先级** - 类型安全问题，建议近期修复

## 5. 集合操作改进方案

### 目标

改进集合操作，支持完整的 NULL 语义和 Map 类型。

### 实现步骤

#### 步骤 1: 修改 IN 操作

**文件**: `src/expression/evaluator/collection_operations.rs`

```rust
pub fn eval_in_operation(
    left: &Value,
    right: &Value,
) -> Result<Value, ExpressionError> {
    // 如果右侧是 NULL（非 BadNull），返回 NULL
    if right.is_null() && !right.is_bad_null() {
        return Ok(Value::Null);
    }
    
    // 如果左侧是 NULL（非 BadNull），返回 NULL
    if left.is_null() && !left.is_bad_null() {
        return Ok(Value::Null);
    }
    
    match right {
        Value::List(list) => {
            let contains = list.contains(left);
            // 如果不包含但列表中有 NULL，返回 NULL
            if !contains && list.contains(&Value::Null) {
                Ok(Value::Null)
            } else {
                Ok(Value::Bool(contains))
            }
        }
        Value::Set(set) => {
            let contains = set.contains(left);
            // 如果不包含但集合中有 NULL，返回 NULL
            if !contains && set.contains(&Value::Null) {
                Ok(Value::Null)
            } else {
                Ok(Value::Bool(contains))
            }
        }
        Value::Map(map) => {
            let contains = map.contains_key(left);
            // 如果不包含但映射中有 NULL 键，返回 NULL
            if !contains && map.contains_key(&Value::Null) {
                Ok(Value::Null)
            } else {
                Ok(Value::Bool(contains))
            }
        }
        _ => Err(ExpressionError::InvalidOperation("IN 操作需要列表、集合或映射".to_string())),
    }
}

pub fn eval_not_in_operation(
    left: &Value,
    right: &Value,
) -> Result<Value, ExpressionError> {
    // 如果右侧是 NULL（非 BadNull），返回 NULL
    if right.is_null() && !right.is_bad_null() {
        return Ok(Value::Null);
    }
    
    // 如果左侧是 NULL（非 BadNull），返回 NULL
    if left.is_null() && !left.is_bad_null() {
        return Ok(Value::Null);
    }
    
    match right {
        Value::List(list) => {
            let contains = list.contains(left);
            // 如果包含但列表中有 NULL，返回 NULL
            if contains && list.contains(&Value::Null) {
                Ok(Value::Null)
            } else {
                Ok(Value::Bool(!contains))
            }
        }
        Value::Set(set) => {
            let contains = set.contains(left);
            // 如果包含但集合中有 NULL，返回 NULL
            if contains && set.contains(&Value::Null) {
                Ok(Value::Null)
            } else {
                Ok(Value::Bool(!contains))
            }
        }
        Value::Map(map) => {
            let contains = map.contains_key(left);
            // 如果包含但映射中有 NULL 键，返回 NULL
            if contains && map.contains_key(&Value::Null) {
                Ok(Value::Null)
            } else {
                Ok(Value::Bool(!contains))
            }
        }
        _ => Err(ExpressionError::InvalidOperation("NOT IN 操作需要列表、集合或映射".to_string())),
    }
}
```

#### 步骤 2: 添加单元测试

**文件**: `src/expression/evaluator/tests/collection_test.rs`

```rust
use crate::core::value::types::Value;
use crate::expression::evaluator::collection_operations;

#[test]
fn test_in_operation_list() {
    let left = Value::Int(1);
    let right = Value::List(vec![Value::Int(1), Value::Int(2), Value::Int(3)]);
    
    let result = collection_operations::eval_in_operation(&left, &right).unwrap();
    assert_eq!(result, Value::Bool(true));
}

#[test]
fn test_in_operation_list_with_null() {
    let left = Value::Int(4);
    let right = Value::List(vec![Value::Int(1), Value::Null, Value::Int(3)]);
    
    let result = collection_operations::eval_in_operation(&left, &right).unwrap();
    assert_eq!(result, Value::Null);
}

#[test]
fn test_in_operation_null_left() {
    let left = Value::Null;
    let right = Value::List(vec![Value::Int(1), Value::Int(2), Value::Int(3)]);
    
    let result = collection_operations::eval_in_operation(&left, &right).unwrap();
    assert_eq!(result, Value::Null);
}

#[test]
fn test_in_operation_null_right() {
    let left = Value::Int(1);
    let right = Value::Null;
    
    let result = collection_operations::eval_in_operation(&left, &right).unwrap();
    assert_eq!(result, Value::Null);
}

#[test]
fn test_in_operation_map() {
    let left = Value::String("key".to_string());
    let mut map = std::collections::HashMap::new();
    map.insert(Value::String("key".to_string()), Value::Int(1));
    let right = Value::Map(map);
    
    let result = collection_operations::eval_in_operation(&left, &right).unwrap();
    assert_eq!(result, Value::Bool(true));
}
```

### 优先级

**中优先级** - 功能完善问题，建议近期修复

## 实施计划

### 第一阶段（高优先级）

1. **LIKE 操作实现** - 预计 2-3 天
   - 实现 LIKE 匹配逻辑
   - 添加单元测试
   - 集成测试

2. **Date 转换修复** - 预计 1-2 天
   - 实现日期计算辅助函数
   - 修改 row_reader.rs
   - 添加单元测试

3. **DateTime 转换修复** - 预计 1 天
   - 实现时间戳转换函数
   - 修改 row_reader.rs
   - 添加单元测试

### 第二阶段（中优先级）

4. **ColumnDef 类型定义改进** - 预计 2-3 天
   - 定义 FieldType 枚举
   - 更新所有使用 ColumnDef 的代码
   - 添加单元测试

5. **集合操作改进** - 预计 1-2 天
   - 修改 IN 和 NOT IN 操作
   - 添加 Map 支持
   - 添加单元测试

### 第三阶段（低优先级）

6. **错误处理改进** - 预计 2-3 天
   - 定义明确的错误类型
   - 更新所有错误处理代码
   - 添加错误测试

7. **类型转换改进** - 预计 1-2 天
   - 改进类型转换错误处理
   - 添加类型转换测试

## 测试策略

### 单元测试

- 为每个新函数添加单元测试
- 覆盖边界情况
- 测试 NULL 值处理
- 测试错误情况

### 集成测试

- 测试表达式求值器的完整流程
- 测试与存储层的集成
- 测试与查询引擎的集成

### 回归测试

- 确保修改不会破坏现有功能
- 运行完整的测试套件
- 性能测试

## 风险评估

### 高风险

- Date 和 DateTime 转换可能影响现有数据
- ColumnDef 类型变更可能需要数据迁移

### 中风险

- LIKE 操作实现可能存在性能问题
- 集合操作的 NULL 语义可能与现有代码不一致

### 低风险

- 错误处理改进
- 类型转换改进

## 回滚计划

如果修改导致问题，可以：
1. 使用 Git 回滚到修改前的版本
2. 保留测试代码，便于后续修复
3. 记录问题，分析根本原因

## 总结

本修改方案提供了详细的实施步骤和代码示例，建议按照优先级逐步实施。在实施过程中，应该：
1. 先实现高优先级的功能
2. 每个阶段完成后进行充分测试
3. 确保不会破坏现有功能
4. 记录所有修改和测试结果

通过这些修改，将显著提高代码质量、数据准确性和与 nebula-graph 的一致性。

# 简化实现分析

## 概述

本文档分析了 `src\expression` 目录中使用的简化实现，以及这些简化实现可能带来的问题和改进方向。

## 简化实现位置汇总

### 1. LIKE 操作未实现

**位置**: `src\expression\evaluator\expression_evaluator.rs:712`

**当前代码**:
```rust
pub fn eval_like(
    _value: &Value,
    _pattern: &Value,
    _escape_char: Option<char>,
) -> Result<Value, ExpressionError> {
    todo!("LIKE操作实现")
}
```

**问题**:
- LIKE 操作完全未实现
- 返回 `todo!()` 宏，会在运行时 panic
- 这是一个关键功能缺失

**影响**:
- 无法执行 SQL LIKE 查询
- 影响图数据库的查询能力

**nebula-graph 实现**:
- nebula-graph 没有独立的 LIKE 操作
- 使用正则表达式操作 (`kRelREG`) 实现类似功能
- 在 `RelationalExpression.cpp:62` 中实现

**改进方向**:
- 实现 LIKE 操作，支持通配符 `%` 和 `_`
- 支持自定义转义字符
- 参考标准 SQL LIKE 语法

### 2. Date 转换简化实现

**位置**: `src\expression\storage\row_reader.rs:423`

**当前代码**:
```rust
// 将天数转换为DateValue（简化实现，从1970-01-01开始计算）
Ok(Value::Date(crate::core::value::DateValue {
    year: 1970 + (days / 365) as i32,
    month: ((days % 365) / 30 + 1) as u32,
    day: ((days % 365) % 30 + 1) as u32,
}))
```

**问题**:
- 使用固定的 365 天计算年份，不考虑闰年
- 使用固定的 30 天计算月份，不考虑实际月份天数
- 结果不准确，特别是对于闰年和不同月份

**影响**:
- 日期计算不准确
- 可能导致数据不一致
- 与标准日期库行为不一致

**nebula-graph 实现**:
```cpp
int64_t Date::toInt() const {
    // Year
    int64_t yearsPassed = year + 32768L;
    int64_t days = yearsPassed * 365L;
    // Add one day per leap year
    if (yearsPassed > 0) {
        days += (yearsPassed - 1) / 4 + 1;
    }

    // Month
    if (yearsPassed % 4 == 0) {
        // Leap year
        days += kLeapDaysSoFar[month - 1];
    } else {
        days += kDaysSoFar[month - 1];
    }

    // Day
    days += day;

    // Since we start from -32768/1/1, we need to reduce one day
    return days - 1;
}
```

**改进方向**:
- 使用 `chrono` crate 进行日期计算
- 或者移植 nebula-graph 的日期计算逻辑
- 正确处理闰年和不同月份的天数

### 3. DateTime 转换简化实现

**位置**: `src\expression\storage\row_reader.rs:441`

**当前代码**:
```rust
// 将时间戳转换为DateTimeValue（简化实现，总是返回1970-01-01）
Ok(Value::DateTime(crate::core::value::DateTimeValue {
    date: crate::core::value::DateValue {
        year: 1970,
        month: 1,
        day: 1,
    },
    time: crate::core::value::TimeValue {
        hour: ((timestamp / 3600) % 24) as u8,
        minute: ((timestamp / 60) % 60) as u8,
        second: (timestamp % 60) as u8,
        microsecond: 0,
    },
}))
```

**问题**:
- 总是返回 1970-01-01 作为日期部分
- 只计算了时间部分
- 没有使用时间戳计算实际日期

**影响**:
- DateTime 值不准确
- 丢失日期信息
- 与标准时间库行为不一致

**nebula-graph 实现**:
- DateTime 包含 Date 和 Time 两个部分
- 使用与 Date 相同的计算逻辑
- 支持完整的日期时间转换

**改进方向**:
- 使用时间戳计算完整的日期时间
- 使用 `chrono` crate 或移植 nebula-graph 的逻辑
- 正确处理时区（如果需要）

### 4. ColumnDef 类型定义简化

**位置**: `src\expression\storage\types.rs:15`

**当前代码**:
```rust
/// 列定义（简化版本，保持向后兼容）
#[derive(Debug, Clone)]
pub struct ColumnDef {
    pub name: String,
    pub data_type: String,
    pub nullable: bool,
}
```

**问题**:
- 使用 `String` 表示数据类型，而不是枚举
- 缺少类型安全
- 容易出现拼写错误
- 无法在编译时验证类型有效性

**影响**:
- 类型不安全
- 容易出现运行时错误
- 增加维护成本

**nebula-graph 实现**:
```cpp
enum class Type : uint64_t {
    __EMPTY__ = 1UL,
    BOOL = 1UL << 1,
    INT = 1UL << 2,
    FLOAT = 1UL << 3,
    STRING = 1UL << 4,
    DATE = 1UL << 5,
    TIME = 1UL << 6,
    DATETIME = 1UL << 7,
    // ...
};
```

**改进方向**:
- 使用枚举类型表示数据类型
- 提供类型安全的 API
- 支持类型转换和验证

### 5. 错误处理简化

**位置**: `src\expression\storage\row_reader.rs` 多处

**当前代码**:
```rust
Err(format!("无法读取列: {}", column_name).into())
```

**问题**:
- 返回字符串作为错误
- 缺少错误类型系统
- 难以区分不同类型的错误

**影响**:
- 错误处理不统一
- 难以进行错误恢复
- 调试困难

**改进方向**:
- 定义明确的错误类型
- 使用 `Result<T, E>` 模式
- 提供详细的错误信息

### 6. 类型转换简化

**位置**: `src\expression\evaluator\expression_evaluator.rs` 多处

**当前代码**:
```rust
Value::Int(value.as_i64().unwrap_or(0))
```

**问题**:
- 使用 `unwrap_or(0)` 忽略错误
- 可能掩盖类型转换错误
- 缺少错误处理

**影响**:
- 数据可能被静默转换
- 难以发现类型错误
- 可能导致数据不一致

**改进方向**:
- 使用 `?` 操作符正确处理错误
- 提供明确的类型转换错误
- 记录转换失败的情况

### 7. 集合操作简化

**位置**: `src\expression\evaluator\collection_operations.rs`

**当前代码**:
```rust
pub fn eval_in_operation(
    left: &Value,
    right: &Value,
) -> Result<Value, ExpressionError> {
    match right {
        Value::List(list) => Ok(Value::Bool(list.contains(left))),
        Value::Set(set) => Ok(Value::Bool(set.contains(left))),
        _ => Err(ExpressionError::InvalidOperation("IN 操作需要列表或集合".to_string())),
    }
}
```

**问题**:
- 没有处理 NULL 值
- 没有处理嵌套集合
- 缺少对 Map 类型的支持

**nebula-graph 实现**:
```cpp
case Kind::kRelIn: {
    if (rhs.isNull() && !rhs.isBadNull()) {
        result_ = Value::kNullValue;
    } else if (rhs.isList()) {
        auto& list = rhs.getList();
        result_ = list.contains(lhs);
        if (UNLIKELY(result_.isBool() && !result_.getBool() && list.contains(Value::kNullValue))) {
            result_ = Value::kNullValue;
        }
    } else if (rhs.isSet()) {
        auto& set = rhs.getSet();
        result_ = set.contains(lhs);
        if (UNLIKELY(result_.isBool() && !result_.getBool() && set.contains(Value::kNullValue))) {
            result_ = Value::kNullValue;
        }
    } else if (rhs.isMap()) {
        auto& map = rhs.getMap();
        result_ = map.contains(lhs);
        if (UNLIKELY(result_.isBool() && !result_.getBool() && map.contains(Value::kNullValue))) {
            result_ = Value::kNullValue;
        }
    } else {
        result_ = Value(NullType::BAD_TYPE);
    }

    if (UNLIKELY(!result_.isBadNull() && lhs.isNull())) {
        result_ = Value::kNullValue;
    }
    break;
}
```

**改进方向**:
- 正确处理 NULL 值
- 支持 Map 类型
- 实现与 nebula-graph 一致的语义

## 优先级排序

### 高优先级（立即修复）

1. **LIKE 操作实现** - 关键功能缺失
2. **Date 转换** - 数据准确性问题
3. **DateTime 转换** - 数据准确性问题

### 中优先级（近期修复）

4. **ColumnDef 类型定义** - 类型安全问题
5. **错误处理** - 代码质量问题

### 低优先级（长期改进）

6. **类型转换** - 改进错误处理
7. **集合操作** - 功能完善

## 总结

当前 `src\expression` 目录中存在多处简化实现，这些简化实现虽然可以快速实现功能，但存在以下问题：

1. **功能不完整** - LIKE 操作未实现
2. **数据不准确** - Date 和 DateTime 转换不准确
3. **类型不安全** - 使用 String 而不是枚举
4. **错误处理不当** - 忽略错误或返回字符串
5. **与 nebula-graph 不一致** - 行为不一致

建议按照优先级逐步修复这些问题，以提高代码质量、数据准确性和与 nebula-graph 的一致性。

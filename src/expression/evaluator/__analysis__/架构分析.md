# ExpressionEvaluator 架构分析

## 概述

本文档分析 `expression_evaluator.rs` 的当前架构，并与 Nebula-Graph 的实现进行对比。

## 当前架构分析

### 文件结构

- **文件路径**: `src/expression/evaluator/expression_evaluator.rs`
- **代码行数**: 约 1399 行
- **主要职责**: 表达式求值器的核心实现

### 核心组件

#### 1. ExpressionEvaluator 结构体

```rust
#[derive(Debug)]
pub struct ExpressionEvaluator;
```

- **设计模式**: 无状态单例模式
- **优点**: 无需实例化状态，线程安全
- **缺点**: 所有方法都需要传递 self 参数

#### 2. 公共接口方法

##### evaluate 方法
```rust
pub fn evaluate(
    &self,
    expr: &Expression,
    context: &mut dyn ExpressionContext,
) -> Result<Value, ExpressionError>
```

- **用途**: 公共求值接口，使用 dyn trait object
- **设计意图**: 向后兼容，支持动态分发
- **性能影响**: 存在虚表调用开销

##### eval_expression_generic 方法
```rust
pub fn eval_expression_generic<C: ExpressionContext>(
    &self,
    expr: &Expression,
    context: &mut C,
) -> Result<Value, ExpressionError>
```

- **用途**: 泛型版本的求值接口
- **设计意图**: 避免虚表开销，支持编译器内联
- **性能优势**: 零成本抽象，完全静态分发

#### 3. 表达式类型处理

当前支持的表达式类型（按类别分类）：

##### 基础表达式
- `Literal`: 字面量
- `Variable`: 变量引用
- `Property`: 属性访问

##### 运算表达式
- `Binary`: 二元运算（算术、比较、逻辑、字符串、集合）
- `Unary`: 一元运算（算术、逻辑、存在性检查）
- `UnaryPlus`, `UnaryNegate`, `UnaryNot`, `UnaryIncr`, `UnaryDecr`: 扩展一元运算

##### 类型转换
- `TypeCast`: 类型转换
- `TypeCasting`: 类型转换（向后兼容）

##### 函数调用
- `Function`: 内置函数调用
- `Aggregate`: 聚合函数

##### 条件表达式
- `Case`: CASE WHEN 表达式

##### 集合表达式
- `List`: 列表构造
- `Map`: 映射构造
- `Subscript`: 下标访问
- `Range`: 范围访问
- `SubscriptRange`: 范围访问（向后兼容）

##### 路径表达式
- `Path`: 路径构造
- `PathBuild`: 路径构建（向后兼容）

##### 图数据库特定表达式
- `Label`: 标签表达式
- `TagProperty`: 标签属性访问
- `EdgeProperty`: 边属性访问
- `InputProperty`: 输入属性访问
- `VariableProperty`: 变量属性访问
- `SourceProperty`: 源属性访问
- `DestinationProperty`: 目的属性访问

##### 高级表达式
- `ListComprehension`: 列表推导
- `Predicate`: 谓词表达式
- `Reduce`: 归约表达式

##### 其他表达式
- `IsNull`, `IsNotNull`: NULL 检查
- `IsEmpty`, `IsNotEmpty`: 空值检查
- `ESQuery`: 文本搜索（未实现）
- `UUID`: UUID 生成
- `MatchPathPattern`: 匹配路径模式

#### 4. 辅助方法

##### 运算求值方法
- `eval_binary_operation`: 二元运算求值
- `eval_unary_operation`: 一元运算求值
- `eval_type_cast`: 类型转换
- `eval_subscript_access`: 下标访问
- `eval_range_access`: 范围访问
- `eval_property_access`: 属性访问

##### 函数求值方法
- `eval_function_call`: 内置函数调用
- `eval_aggregate_function_single`: 单参数聚合函数
- `eval_aggregate_function`: 多参数聚合函数

##### 图数据库特定方法
- `eval_label_expression`: 标签表达式求值
- `eval_tag_property`: 标签属性求值
- `eval_edge_property`: 边属性求值
- `eval_variable_property`: 变量属性求值
- `eval_source_property`: 源属性求值
- `eval_destination_property`: 目的属性求值

##### 特殊操作方法
- `eval_like_operation`: LIKE 操作
- `eval_case_expression`: CASE 表达式求值

## 与 Nebula-Graph 的对比

### 架构差异

#### 1. 表达式类层次结构

**Nebula-Graph (C++)**:
- 使用继承层次结构
- 基类 `Expression` 定义统一接口
- 每种表达式类型有独立的子类
- 使用虚函数实现多态

**用户实现 (Rust)**:
- 使用枚举 `Expression` 表示所有表达式类型
- 通过模式匹配分发到不同的求值逻辑
- 使用 trait 实现多态

#### 2. 求值机制

**Nebula-Graph**:
```cpp
Value Expression::eval(ExpressionContext& ctx) = 0;
```
- 每个表达式子类实现自己的 `eval` 方法
- 使用虚函数表进行动态分发
- 支持嵌套上下文 (`ctx.spawn()`)

**用户实现**:
```rust
pub fn eval_expression_generic<C: ExpressionContext>(
    &self,
    expr: &Expression,
    context: &mut C,
) -> Result<Value, ExpressionError>
```
- 单一求值器处理所有表达式类型
- 使用模式匹配进行静态分发
- 泛型版本支持零成本抽象

#### 3. 上下文管理

**Nebula-Graph**:
- 使用 `ExpressionContext` 基类
- 支持嵌套上下文 (`spawn()` 方法)
- 避免上下文污染

**用户实现**:
- 使用 `ExpressionContext` trait
- 当前不支持嵌套上下文
- 可能存在上下文污染风险

### 功能差异

#### 1. ListComprehension 表达式

**Nebula-Graph**:
- 支持完整语法: `[x IN list WHERE condition | mapping]`
- 包含初始值、过滤条件和映射表达式
- 使用嵌套上下文避免污染

**用户实现**:
- 仅支持: `[x IN list WHERE condition]`
- 缺少映射表达式功能
- 不支持迭代变量绑定
- 直接使用传入上下文

#### 2. Reduce 表达式

**Nebula-Graph**:
- 使用嵌套上下文
- 正确处理非列表情况

**用户实现**:
- 直接使用传入上下文
- 可能导致上下文污染

#### 3. 错误处理

**Nebula-Graph**:
- 依赖类型系统和运行时检查
- 错误信息相对简单

**用户实现**:
- 使用 Rust 的 `Result` 类型
- 提供明确的错误类型和错误信息
- 更好的类型安全

### 性能差异

#### 1. 动态分发 vs 静态分发

**Nebula-Graph**:
- 使用虚函数表（动态分发）
- 每次调用有虚表查找开销

**用户实现**:
- 提供两种接口:
  - `evaluate`: 使用 dyn trait object（动态分发）
  - `eval_expression_generic`: 使用泛型（静态分发）
- 泛型版本支持完全内联，零成本抽象

#### 2. 内存管理

**Nebula-Graph**:
- 使用 `ObjectPool` 管理内存
- 手动管理对象生命周期

**用户实现**:
- 利用 Rust 所有权系统
- 编译时内存安全保证
- 零开销抽象

## 当前架构的问题

### 1. 单一职责原则违反

**问题**: `ExpressionEvaluator` 承担了太多职责
- 表达式分发
- 运算求值
- 函数调用
- 图数据库特定操作
- 错误处理

**影响**:
- 文件过大（1399 行）
- 难以维护和测试
- 违反单一职责原则

### 2. 代码重复

**问题**: `eval_expression` 和 `eval_expression_generic` 存在大量重复代码

**影响**:
- 维护成本高
- 容易出现不一致
- 增加代码复杂度

### 3. 缺少嵌套上下文支持

**问题**: 当前实现不支持嵌套上下文

**影响**:
- 可能导致上下文污染
- 与 Nebula-Graph 行为不一致
- 某些表达式求值可能不正确

### 4. 向后兼容代码冗余

**问题**: 存在多个向后兼容的表达式变体

**示例**:
- `Range` vs `SubscriptRange`
- `Path` vs `PathBuild`
- `TypeCast` vs `TypeCasting`

**影响**:
- 增加维护负担
- 可能导致混淆

### 5. 功能不完整

**问题**: 某些高级功能未实现

**示例**:
- `ListComprehension` 缺少映射表达式
- `ESQuery` 未实现
- `MatchPathPattern` 仅返回列表

## 性能分析

### 虚表开销

**当前实现**:
- `evaluate` 方法使用 `dyn ExpressionContext`
- 每次调用有虚表查找开销
- 对于频繁调用的表达式（如 `Literal`, `Variable`），开销显著

**优化方案**:
- 使用 `eval_expression_generic` 方法
- 编译器可以为每个具体类型生成专用代码
- 支持完全内联，消除虚表开销

### 内存分配

**当前实现**:
- 大量使用 `clone()` 操作
- 可能导致不必要的内存分配

**优化方案**:
- 使用引用传递
- 考虑使用 `Cow` 类型
- 优化 Value 类型的克隆策略

## 总结

### 优势

1. **类型安全**: 利用 Rust 类型系统确保编译时安全
2. **零成本抽象**: 泛型版本支持完全内联
3. **错误处理**: 使用 Result 类型提供明确的错误信息
4. **内存安全**: 编译时保证内存安全

### 劣势

1. **单一职责违反**: 承担太多职责
2. **代码重复**: 两个求值方法存在大量重复
3. **功能不完整**: 某些高级功能未实现
4. **缺少嵌套上下文**: 可能导致上下文污染
5. **向后兼容代码冗余**: 增加维护负担

### 改进方向

1. 模块化拆分，遵循单一职责原则
2. 消除代码重复
3. 添加嵌套上下文支持
4. 完善高级功能实现
5. 清理向后兼容代码

# ExpressionEvaluator 修改方案

## 目标

1. 重构 `expression_evaluator.rs` 以遵循单一职责原则
2. 消除代码重复
3. 添加嵌套上下文支持
4. 完善高级功能实现
5. 清理向后兼容代码
6. 确保不引入额外运行时开销

## 模块拆分方案

### 1. 核心模块划分

#### expression_evaluator.rs (主求值器)
**职责**: 表达式分发和求值协调

**内容**:
- `ExpressionEvaluator` 结构体
- `evaluate` 方法（公共接口，向后兼容）
- `eval_expression_generic` 方法（泛型接口，高性能）
- `evaluate_batch` 方法
- `can_evaluate` 方法
- 元数据方法（`name`, `description`, `version`）

**设计原则**:
- 保持最小化，仅负责表达式分发
- 将具体求值逻辑委托给专门的模块
- 确保所有方法都可以内联

#### operations.rs (运算求值)
**职责**: 各种运算的求值逻辑

**内容**:
- `eval_binary_operation`: 二元运算求值
- `eval_unary_operation`: 一元运算求值
- `eval_type_cast`: 类型转换
- `eval_subscript_access`: 下标访问
- `eval_range_access`: 范围访问
- `eval_property_access`: 属性访问

**设计原则**:
- 纯函数，无状态
- 所有参数通过引用传递
- 支持完全内联

#### functions.rs (函数调用)
**职责**: 内置函数和聚合函数的求值逻辑

**内容**:
- `eval_function_call`: 内置函数调用
- `eval_aggregate_function_single`: 单参数聚合函数
- `eval_aggregate_function`: 多参数聚合函数

**设计原则**:
- 纯函数，无状态
- 所有参数通过引用传递
- 支持完全内联

#### graph_operations.rs (图数据库操作)
**职责**: 图数据库特定的表达式求值

**内容**:
- `eval_label_expression`: 标签表达式求值
- `eval_tag_property`: 标签属性求值
- `eval_edge_property`: 边属性求值
- `eval_variable_property`: 变量属性求值
- `eval_source_property`: 源属性求值
- `eval_destination_property`: 目的属性求值

**设计原则**:
- 依赖 `ExpressionContext` trait
- 支持完全内联

#### collection_operations.rs (集合操作)
**职责**: 集合类型表达式的求值逻辑

**内容**:
- `eval_list_expression`: 列表表达式求值
- `eval_map_expression`: 映射表达式求值
- `eval_list_comprehension`: 列表推导求值
- `eval_predicate_expression`: 谓词表达式求值
- `eval_reduce_expression`: 归约表达式求值

**设计原则**:
- 纯函数，无状态
- 所有参数通过引用传递
- 支持完全内联

#### special_operations.rs (特殊操作)
**职责**: 特殊表达式的求值逻辑

**内容**:
- `eval_like_operation`: LIKE 操作
- `eval_case_expression`: CASE 表达式求值
- `eval_uuid_expression`: UUID 生成

**设计原则**:
- 纯函数，无状态
- 所有参数通过引用传递
- 支持完全内联

### 2. 模块依赖关系

```
expression_evaluator.rs (主模块)
    ├── operations.rs
    ├── functions.rs
    ├── graph_operations.rs
    ├── collection_operations.rs
    └── special_operations.rs
```

**依赖原则**:
- 所有子模块之间相互独立
- 仅主模块依赖子模块
- 子模块不依赖主模块
- 避免循环依赖

### 3. 性能保证

#### 零成本抽象
- 所有子模块的方法都标记为 `#[inline]`
- 编译器可以完全内联所有调用
- 不引入虚表开销

#### 泛型优化
- `eval_expression_generic` 方法使用泛型参数
- 编译器为每个具体类型生成专用代码
- 支持完全静态分发

#### 引用传递
- 所有参数通过引用传递
- 避免不必要的克隆
- 减少内存分配

## 功能改进方案

### 1. 嵌套上下文支持

#### 问题
当前实现不支持嵌套上下文，可能导致上下文污染

#### 解决方案

**步骤 1**: 扩展 `ExpressionContext` trait
```rust
pub trait ExpressionContext {
    // 现有方法
    fn get_variable(&self, name: &str) -> Option<Value>;
    fn set_variable(&mut self, name: String, value: Value);
    fn get_vertex(&self) -> Option<&Vertex>;
    fn get_edge(&self) -> Option<&Edge>;

    // 新增方法
    fn spawn(&self) -> Box<dyn ExpressionContext>;
}
```

**步骤 2**: 修改 `ListComprehension` 求值逻辑
- 使用 `context.spawn()` 创建嵌套上下文
- 在嵌套上下文中绑定迭代变量
- 避免污染外层上下文

**步骤 3**: 修改 `Reduce` 求值逻辑
- 使用 `context.spawn()` 创建嵌套上下文
- 在嵌套上下文中绑定迭代变量
- 避免污染外层上下文

### 2. ListComprehension 功能完善

#### 问题
当前实现缺少映射表达式功能

#### 解决方案

**步骤 1**: 扩展 `Expression` 枚举
```rust
Expression::ListComprehension {
    collection: Box<Expression>,
    variable: String,
    filter: Option<Box<Expression>>,
    mapping: Option<Box<Expression>>,
}
```

**步骤 2**: 实现完整的列表推导逻辑
- 评估集合表达式
- 遍历集合元素
- 在嵌套上下文中绑定迭代变量
- 评估过滤条件（如果存在）
- 评估映射表达式（如果存在）
- 收集结果

**步骤 3**: 更新测试用例
- 添加映射表达式的测试
- 验证与 Nebula-Graph 的一致性

### 3. ESQuery 实现

#### 问题
当前 `ESQuery` 表达式未实现，仅返回 null

#### 解决方案

**步骤 1**: 设计 ESQuery 接口
```rust
pub trait ESQueryEngine {
    fn query(&self, index: &str, query: &str) -> Result<Vec<Value>, ExpressionError>;
}
```

**步骤 2**: 实现基础 ESQuery 求值逻辑
- 解析查询参数
- 调用 ESQueryEngine
- 返回查询结果

**步骤 3**: 集成到 ExpressionEvaluator
- 在 `eval_expression_generic` 中处理 `ESQuery` 表达式
- 使用依赖注入传递 ESQueryEngine

### 4. MatchPathPattern 实现

#### 问题
当前 `MatchPathPattern` 仅返回列表，未实现实际匹配逻辑

#### 解决方案

**步骤 1**: 设计路径匹配接口
```rust
pub trait PathMatcher {
    fn match_pattern(&self, pattern: &PathPattern, context: &mut dyn ExpressionContext) -> Result<Vec<Value>, ExpressionError>;
}
```

**步骤 2**: 实现路径匹配逻辑
- 解析路径模式
- 在上下文中查找匹配的路径
- 返回匹配结果

**步骤 3**: 集成到 ExpressionEvaluator
- 在 `eval_expression_generic` 中处理 `MatchPathPattern` 表达式
- 使用依赖注入传递 PathMatcher

## 向后兼容代码清理

### 1. 重复表达式变体

#### Range vs SubscriptRange

**分析**:
- `Range`: 标准的范围访问表达式
- `SubscriptRange`: 向后兼容的变体

**建议**:
- 保留 `Range` 作为标准实现
- 删除 `SubscriptRange`
- 在解析层将 `SubscriptRange` 转换为 `Range`

#### Path vs PathBuild

**分析**:
- `Path`: 标准的路径构造表达式
- `PathBuild`: 向后兼容的变体

**建议**:
- 保留 `Path` 作为标准实现
- 删除 `PathBuild`
- 在解析层将 `PathBuild` 转换为 `Path`

#### TypeCast vs TypeCasting

**分析**:
- `TypeCast`: 标准的类型转换表达式
- `TypeCasting`: 向后兼容的变体（未实现）

**建议**:
- 保留 `TypeCast` 作为标准实现
- 删除 `TypeCasting`
- 在解析层将 `TypeCasting` 转换为 `TypeCast`

### 2. 一元运算扩展

#### UnaryPlus, UnaryNegate, UnaryNot, UnaryIncr, UnaryDecr

**分析**:
- 这些表达式是 `Unary` 的特化版本
- 可以用 `Unary` 表达式表示

**建议**:
- 保留这些变体以提高可读性
- 在求值时转换为 `Unary` 表达式
- 不删除，因为它们提供了更好的语义

### 3. 属性访问变体

#### InputProperty, VariableProperty, SourceProperty, DestinationProperty

**分析**:
- 这些是图数据库特定的属性访问变体
- 提供了更清晰的语义

**建议**:
- 保留这些变体
- 它们是图数据库查询语言的一部分
- 删除会降低代码可读性

## 代码重复消除

### 1. eval_expression vs eval_expression_generic

**问题**: 两个方法存在大量重复代码

**解决方案**:

**方案 A**: 统一使用泛型版本
- 删除 `eval_expression` 方法
- 将 `evaluate` 方法改为直接调用 `eval_expression_generic`
- 使用类型擦除将 `dyn ExpressionContext` 转换为泛型参数

**方案 B**: 提取公共逻辑
- 创建私有方法 `eval_expression_impl`
- `eval_expression` 和 `eval_expression_generic` 都调用这个方法
- 使用宏或泛型避免重复

**推荐**: 方案 A
- 更简洁
- 性能更好
- 维护成本更低

### 2. 聚合函数求值

**问题**: `eval_aggregate_function_single` 和 `eval_aggregate_function` 存在重复逻辑

**解决方案**:
- 统一使用 `eval_aggregate_function`
- 单参数情况作为多参数的特例
- 删除 `eval_aggregate_function_single`

## 实施计划

### 阶段 1: 模块拆分（高优先级）

**目标**: 重构代码结构，遵循单一职责原则

**步骤**:
1. 创建 `operations.rs` 模块
2. 创建 `functions.rs` 模块
3. 创建 `graph_operations.rs` 模块
4. 创建 `collection_operations.rs` 模块
5. 创建 `special_operations.rs` 模块
6. 更新 `expression_evaluator.rs` 以使用新模块
7. 更新 `mod.rs` 导出新模块
8. 运行测试确保功能正常

**预期结果**:
- 代码结构清晰
- 每个模块职责单一
- 无性能损失

### 阶段 2: 消除代码重复（高优先级）

**目标**: 消除 `eval_expression` 和 `eval_expression_generic` 的重复

**步骤**:
1. 分析两个方法的差异
2. 设计统一的实现方案
3. 实现统一的求值逻辑
4. 删除重复代码
5. 运行测试确保功能正常

**预期结果**:
- 代码量减少
- 维护成本降低
- 无性能损失

### 阶段 3: 嵌套上下文支持（中优先级）

**目标**: 添加嵌套上下文支持，避免上下文污染

**步骤**:
1. 扩展 `ExpressionContext` trait
2. 实现嵌套上下文逻辑
3. 更新 `ListComprehension` 求值
4. 更新 `Reduce` 求值
5. 运行测试确保功能正常

**预期结果**:
- 避免上下文污染
- 与 Nebula-Graph 行为一致

### 阶段 4: ListComprehension 功能完善（中优先级）

**目标**: 实现完整的列表推导功能

**步骤**:
1. 扩展 `Expression` 枚举
2. 实现映射表达式逻辑
3. 更新求值逻辑
4. 添加测试用例
5. 运行测试确保功能正常

**预期结果**:
- 支持完整的列表推导语法
- 与 Nebula-Graph 行为一致

### 阶段 5: 向后兼容代码清理（低优先级）

**目标**: 清理不必要的向后兼容代码

**步骤**:
1. 分析所有向后兼容的变体
2. 确定哪些可以删除
3. 在解析层添加转换逻辑
4. 删除冗余变体
5. 运行测试确保功能正常

**预期结果**:
- 代码量减少
- 维护成本降低
- 无功能损失

### 阶段 6: 高级功能实现（低优先级）

**目标**: 实现未完成的高级功能

**步骤**:
1. 实现 `ESQuery` 功能
2. 实现 `MatchPathPattern` 功能
3. 添加测试用例
4. 运行测试确保功能正常

**预期结果**:
- 功能完整
- 与 Nebula-Graph 行为一致

## 风险评估

### 高风险项

1. **模块拆分**
   - 风险: 可能引入编译错误
   - 缓解: 充分测试，逐步迁移

2. **消除代码重复**
   - 风险: 可能影响性能
   - 缓解: 性能测试，基准测试

### 中风险项

1. **嵌套上下文支持**
   - 风险: 可能影响现有功能
   - 缓解: 充分测试，向后兼容

2. **ListComprehension 功能完善**
   - 风险: 可能引入新 bug
   - 缓解: 充分测试，与 Nebula-Graph 对比

### 低风险项

1. **向后兼容代码清理**
   - 风险: 可能破坏现有查询
   - 缓解: 解析层转换，充分测试

2. **高级功能实现**
   - 风险: 可能影响性能
   - 缓解: 性能测试，可选实现

## 性能保证

### 编译器优化

1. **内联优化**
   - 所有子模块方法标记为 `#[inline]`
   - 编译器可以完全内联所有调用
   - 不引入额外开销

2. **静态分发**
   - 使用泛型参数避免虚表调用
   - 编译器为每个具体类型生成专用代码
   - 零成本抽象

3. **引用传递**
   - 所有参数通过引用传递
   - 避免不必要的克隆
   - 减少内存分配

### 性能测试

1. **基准测试**
   - 对比重构前后的性能
   - 确保无性能损失
   - 识别性能瓶颈

2. **内存分析**
   - 分析内存分配情况
   - 优化不必要的克隆
   - 减少内存使用

## 测试策略

### 单元测试

1. **模块测试**
   - 每个子模块独立测试
   - 确保功能正确
   - 覆盖所有边界情况

2. **集成测试**
   - 测试模块之间的交互
   - 确保整体功能正确
   - 覆盖常见用例

### 回归测试

1. **功能测试**
   - 确保现有功能不受影响
   - 覆盖所有表达式类型
   - 验证错误处理

2. **性能测试**
   - 对比重构前后的性能
   - 确保无性能损失
   - 识别性能回归

### 对比测试

1. **与 Nebula-Graph 对比**
   - 验证行为一致性
   - 识别差异
   - 确保兼容性

## 总结

### 核心原则

1. **单一职责**: 每个模块只负责一个方面的功能
2. **零成本抽象**: 不引入额外运行时开销
3. **向后兼容**: 保持现有功能不受影响
4. **渐进式改进**: 分阶段实施，降低风险

### 预期收益

1. **可维护性**: 代码结构清晰，易于理解和修改
2. **可测试性**: 模块独立，易于测试
3. **可扩展性**: 易于添加新功能
4. **性能**: 保持高性能，无额外开销

### 下一步行动

1. 审查本方案
2. 确认实施计划
3. 开始阶段 1: 模块拆分
4. 逐步推进后续阶段

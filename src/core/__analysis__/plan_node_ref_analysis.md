# PlanNodeRef 模块分析

## 模块作用

`PlanNodeRef` 模块提供了一个轻量级的计划节点引用机制，用于在符号表系统中跟踪变量与查询计划节点之间的依赖关系。该模块的主要作用包括：

1. **轻量级引用**：提供对计划节点的轻量级引用，避免在符号表中存储完整的节点对象
2. **依赖跟踪**：支持符号表系统跟踪哪些计划节点读取或写入特定变量
3. **冲突检测**：通过跟踪依赖关系，支持检测多个计划节点对同一变量的并发访问冲突
4. **查询优化**：为查询优化器提供依赖信息，以便进行更有效的执行计划优化

## 实际使用情况

### 1. 在符号表中的使用

`PlanNodeRef` 主要被 `SymbolTable` 模块使用，具体功能包括：

- `read_by()` - 记录变量被计划节点读取
- `written_by()` - 记录变量被计划节点写入
- `get_readers()` - 获取变量的读取者列表
- `get_writers()` - 获取变量的写入者列表
- `get_variables_read_by()` - 获取指定节点读取的所有变量
- `get_variables_written_by()` - 获取指定节点写入的所有变量
- `detect_write_conflicts()` - 检测写入冲突

### 2. 在依赖跟踪器中的使用

`DependencyTracker` 使用 `PlanNodeRef` 来：

- 维护变量与计划节点之间的读写依赖关系
- 支持依赖关系的添加、删除和查询
- 提供依赖统计信息

### 3. 调用示例

在查询执行和验证上下文中，`PlanNodeRef` 被用来：

```rust
let node_ref = PlanNodeRef::new("scan_node_1".to_string(), 123);

// 记录变量被计划节点读取
symbol_table.read_by("vertex_var", node_ref.clone())?;

// 获取读取特定变量的所有计划节点
let readers = symbol_table.get_readers("vertex_var")?;
```

## 设计意图

### 1. 性能优化

- **内存效率**：通过轻量级引用避免存储完整的计划节点对象，减少内存占用
- **零成本抽象**：设计为零成本抽象，只包含必要的标识信息

### 2. 架构解耦

- **低耦合**：`PlanNodeRef` 不依赖于具体的计划节点实现，提供了一个通用的引用机制
- **灵活性**：支持任何类型的计划节点，无需修改 `PlanNodeRef` 的实现

### 3. 功能完整性

- **唯一标识**：通过 `id` 和 `node_id` 提供唯一标识能力
- **类型信息**：通过 `type_name()` 方法提供节点类型信息（尽管当前是简化实现）
- **集合友好**：实现 `Hash`、`Eq` 等 trait，支持在集合中使用

### 4. 扩展性考虑

- **易于扩展**：设计允许后续添加更多元数据而不需要破坏现有接口
- **向后兼容**：API 设计考虑了向后兼容性

## 设计优点

1. **简洁性**：结构简单，只包含必要的字段
2. **效率**：轻量级，适合大量使用场景
3. **一致性**：在整个符号表系统中提供一致的节点引用方式
4. **可测试性**：提供了完整的单元测试覆盖

## 潜在改进点

1. **类型安全**：当前的 `type_name()` 方法是简化实现，可以考虑通过泛型或其他方式提供更强的类型安全
2. **全局注册表**：可以考虑实现一个全局节点注册表，提供更丰富的节点元数据查询功能

## 总结

`PlanNodeRef` 模块是符号表系统的重要组成部分，通过提供轻量级的计划节点引用机制，支持了变量依赖跟踪和冲突检测功能。其设计充分考虑了性能、解耦和扩展性需求，是整个查询执行系统中的关键组件。
# Core模块优化方案

## 概述

本文档提出对Core模块的优化方案，旨在减少类型转换和包装开销，同时保持系统架构的清晰性和可维护性。

## 当前问题

### 1. 重复实现问题
- Core和Expression模块存在重复的操作符定义
- 多个模块包含相似的表达式求值逻辑
- 类型转换和包装导致额外开销

### 2. 循环依赖问题
- Expression和Query模块之间存在循环依赖
- 依赖关系复杂，难以维护

### 3. 性能开销
- 频繁的类型转换操作
- 动态分发（trait object）在性能关键路径上的使用

## 优化方案

### 1. 精简Core模块结构

#### 1.1 保留核心数据结构
- 保留Value、Vertex、Edge、Path等基础数据类型
- 保留错误类型定义（DBError, ExpressionError等）
- 保留基础操作符定义

#### 1.2 移除重复实现
- 移除Expression模块中的重复操作符定义
- 集中表达式求值逻辑到Core层
- 使用重新导出模式提供便利API

### 2. 优化表达式求值器

#### 2.1 泛型优化
```rust
// 优先使用泛型版本，减少动态分发开销
pub fn eval_expression_generic<C: ExpressionContext>(
    &self,
    expr: &Expression,
    context: &mut C,
) -> Result<Value, ExpressionError> {
    // 专用代码，支持完全内联
}
```

#### 2.2 避免不必要的类型转换
- 在内部实现中直接使用Core类型
- 减少在性能关键路径上的类型转换

### 3. 消除循环依赖

#### 3.1 依赖方向统一
- 确保所有模块依赖Core，而不是相互依赖
- Expression模块提供适配器，而不是包装Core类型
- Query模块直接使用Core类型

#### 3.2 重新设计模块接口
- 通过trait定义接口，而不是直接依赖实现
- 使用依赖注入模式，减少硬编码依赖

### 4. 具体实施步骤

#### 第一阶段：清理重复实现
1. 移除Expression模块中的重复操作符定义
2. 统一使用Core模块的表达式类型
3. 更新所有依赖引用

#### 第二阶段：优化求值器性能
1. 实现泛型版本的表达式求值器
2. 为性能关键路径使用泛型实现
3. 减少动态分发的使用

#### 第三阶段：重构依赖关系
1. 消除Expression和Query模块间的循环依赖
2. 确保所有依赖关系是单向的
3. 更新模块间的接口定义

### 5. 预期收益

#### 5.1 性能提升
- 减少类型转换开销
- 降低动态分发的使用
- 提高表达式求值性能

#### 5.2 代码质量提升
- 消除重复实现
- 简化模块间依赖
- 提高代码一致性

#### 5.3 可维护性提升
- 清晰的模块职责
- 统一的类型定义
- 简化的依赖关系

### 6. 风险评估

#### 6.1 兼容性风险
- 修改可能影响现有API
- 需要提供兼容层或迁移指南

#### 6.2 性能风险
- 泛型实现可能导致编译时间增加
- 需要性能基准测试验证

#### 6.3 实施风险
- 重构范围较大
- 需要充分的测试覆盖

### 7. 实施建议

1. **分阶段实施**：避免一次性大规模重构
2. **充分测试**：确保重构后功能正确性
3. **性能基准**：验证优化效果
4. **文档更新**：更新相关设计文档

## 结论

通过精简Core模块、优化表达式求值器、消除循环依赖，可以在保持架构清晰性的同时减少性能开销。关键是找到性能优化和架构清晰性之间的平衡点。
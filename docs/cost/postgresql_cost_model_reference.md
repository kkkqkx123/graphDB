# PostgreSQL 代价模型设计参考

## 概述

PostgreSQL 的查询优化器使用基于代价的优化（Cost-Based Optimization, CBO）策略。该模型通过估算不同执行计划的资源消耗（主要是 I/O 和 CPU），选择代价最低的执行计划。

---

## 核心代价参数

PostgreSQL 使用一组可配置的代价参数来估算各种操作的成本：

### 磁盘 I/O 代价

- **顺序页读取代价（seq_page_cost）**
  - 默认值：1.0
  - 表示顺序读取一个磁盘页面的成本
  - 用于全表扫描等顺序访问场景

- **随机页读取代价（random_page_cost）**
  - 默认值：4.0
  - 表示随机读取一个磁盘页面的成本
  - 通常高于顺序读取，因为随机 I/O 需要更多寻道时间
  - 用于索引扫描等随机访问场景

### CPU 处理代价

- **行处理代价（cpu_tuple_cost）**
  - 默认值：0.01
  - 处理每一行数据的 CPU 成本
  - 应用于所有需要处理元组的操作

- **索引行处理代价（cpu_index_tuple_cost）**
  - 默认值：0.005
  - 处理每个索引项的 CPU 成本
  - 略低于普通行处理，因为索引项通常更小

- **操作符计算代价（cpu_operator_cost）**
  - 默认值：0.0025
  - 执行每个操作符或函数的 CPU 成本
  - 用于评估 WHERE 子句中的条件表达式

---

## 统计信息体系

### 表级统计信息

存储在系统目录 `pg_class` 中：

- **reltuples**：表的估计行数
- **relpages**：表占用的磁盘页数

这些统计信息通过 `ANALYZE` 命令收集，并在 `VACUUM` 操作时更新。

### 列级统计信息

存储在系统视图 `pg_stats` 中：

- **null_frac**：该列中空值的比例
- **avg_width**：该列的平均宽度（字节）
- **n_distinct**：不同值的数量（负数表示比例）
- **most_common_vals（MCV）**：最常见值的列表
- **most_common_freqs**：对应 MCV 的出现频率
- **histogram_bounds**：直方图边界（用于范围查询）
- **correlation**：列值与物理存储顺序的相关性

---

## 代价计算原理

### 顺序扫描代价

顺序扫描（Sequential Scan）的代价计算：

```
总代价 = 磁盘 I/O 代价 + CPU 处理代价
       = (页面数 × seq_page_cost) + (行数 × cpu_tuple_cost)
```

### 索引扫描代价

索引扫描（Index Scan）的代价计算：

```
总代价 = 索引访问代价 + 回表代价

索引访问代价 = (索引页数 × random_page_cost) 
             + (索引行数 × cpu_index_tuple_cost)
             + 条件评估代价

回表代价 = (选择性 × 表行数 × random_page_cost)
         + (选择性 × 表行数 × cpu_tuple_cost)
```

### 连接操作代价

连接操作的代价取决于连接算法：

**嵌套循环连接（Nested Loop Join）**：
```
代价 = 外表扫描代价 + (外表行数 × 内表扫描代价)
```

**哈希连接（Hash Join）**：
```
代价 = 构建哈希表代价 + 探测代价
     = 左输入代价 + 右输入代价 + 哈希构建开销
```

**归并连接（Merge Join）**：
```
代价 = 左输入排序代价 + 右输入排序代价 + 归并代价
```

---

## 选择性估计

选择性（Selectivity）是指满足某个条件的行数占总行数的比例，范围在 0.0 到 1.0 之间。

### 等值条件选择性

**使用 MCV（最常见值）**：
如果查询值在 MCV 列表中，直接使用对应的频率作为选择性。

**非 MCV 值**：
使用均匀分布假设：
```
选择性 = (1 - MCV 总频率) / (不同值数量 - MCV 数量)
```

### 范围条件选择性

使用直方图进行估计：

1. 确定查询值落在哪个直方图桶中
2. 计算该桶内的比例
3. 累加前面所有桶的完整比例

```
选择性 = (前面完整桶数 + 当前桶内比例) / 总桶数
```

### 连接选择性

**等值连接**：
```
选择性 = 1 / max(左表不同值数, 右表不同值数)
```

**考虑空值**：
```
选择性 = (1 - 左表空值率) × (1 - 右表空值率) × 基础选择性
```

---

## 统计信息收集

### ANALYZE 命令

`ANALYZE` 命令负责收集表的统计信息：

1. **采样**：从表中随机采样一定比例的行（默认基于统计目标）
2. **计算基础统计**：行数、空值比例、平均宽度等
3. **识别 MCV**：找出最常见值及其频率
4. **构建直方图**：对非 MCV 值构建等频直方图

### 自动统计更新

PostgreSQL 支持自动统计更新：

- 当表被修改的行数超过阈值时，自动触发统计更新
- 阈值与表的总行数成正比
- 可通过参数配置自动更新的积极性

---

## 代价模型校准

### 参数调整

根据实际硬件环境调整代价参数：

- **SSD 环境**：降低 `random_page_cost`（接近 `seq_page_cost`）
- **内存充足**：降低页面相关代价，提高 CPU 代价权重
- **远程存储**：增加页面相关代价

### 反馈校准

PostgreSQL 支持通过实际执行结果校准统计信息：

- 比较估计行数与实际行数
- 调整统计信息的可信度
- 优化后续查询的计划选择

---

## 对 GraphDB 的启示

PostgreSQL 的代价模型设计提供了以下可借鉴的经验：

1. **分层代价参数**：将 I/O 和 CPU 代价分离，便于针对不同硬件环境调优
2. **丰富的统计信息**：MCV 和直方图结合，兼顾常见值和分布形状
3. **选择性估计的统一框架**：不同类型条件使用一致的估计方法
4. **统计信息的自动维护**：减少人工干预，保持统计信息新鲜度
5. **可扩展的设计**：代价参数可配置，适应不同部署场景

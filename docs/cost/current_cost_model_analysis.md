# GraphDB 当前代价模型分析

## 概述

本文档分析 GraphDB 项目当前的查询优化代价模型实现现状，包括节点代价定义方式、存在的问题以及对优化器的影响。

---

## 代价模型架构

### 核心结构

当前项目采用统一的代价存储模式，每个计划节点都包含一个代价字段：

- 所有节点结构体都包含 `cost: f64` 字段
- 通过 `cost()` 方法返回代价值
- 代价在节点创建时初始化，运行时不改变

### 节点分类与代价初始值

根据功能和实现方式，计划节点可分为以下几类：

#### 1. 起始节点

代表查询计划的起点，无实际数据操作：

- **StartNode**：代价固定为 0.0
- 作为整个计划的根节点，仅标记计划开始

#### 2. 元数据管理节点

处理数据库元数据操作（DDL）：

- **Space 管理**：CreateSpaceNode、DropSpaceNode、DescSpaceNode 等
- **Tag 管理**：CreateTagNode、AlterTagNode、DescTagNode 等
- **Index 管理**：CreateTagIndexNode、DropEdgeIndexNode 等
- **User 管理**：CreateUserNode、AlterUserNode、ChangePasswordNode 等

这些节点的代价统一设置为 1.0，表示轻量级的元数据操作。

#### 3. 数据修改节点

处理数据写入操作（DML）：

- **InsertVerticesNode**：顶点插入操作
- **InsertEdgesNode**：边插入操作

代价固定为 1.0，表示单次写入操作的基础成本。

#### 4. 数据查询节点

处理数据读取操作，是查询计划的主要组成部分：

**图扫描节点**：
- ScanVerticesNode：全表扫描顶点
- ScanEdgesNode：全表扫描边
- GetVerticesNode：根据 ID 获取顶点
- GetEdgesNode：根据条件获取边
- GetNeighborsNode：获取邻居节点

**索引扫描节点**：
- IndexScanNode：标签索引扫描
- EdgeIndexScanNode：边类型索引扫描

**过滤与处理节点**：
- FilterNode：条件过滤
- ProjectNode：投影操作
- DedupNode：去重操作
- LimitNode：结果限制
- SortNode：排序操作
- TopNNode：TopN 查询
- AggregateNode：聚合计算

**集合操作节点**：
- UnionNode：并集操作
- IntersectNode：交集操作
- MinusNode：差集操作

**连接操作节点**：
- InnerJoinNode：内连接
- LeftJoinNode：左连接
- CrossJoinNode：交叉连接
- HashInnerJoinNode：哈希内连接
- HashLeftJoinNode：哈希左连接

**图遍历节点**：
- TraverseNode：图遍历
- ExpandNode：路径展开
- ExpandAllNode：全路径展开
- AppendVerticesNode：追加顶点

**控制流节点**：
- SelectNode：条件选择
- LoopNode：循环执行
- UnwindNode：列表展开
- AssignNode：变量赋值

**特殊操作节点**：
- PatternApplyNode：模式应用
- RollUpApplyNode：递归模式应用

以上所有数据查询节点的代价统一初始化为 0.0。

---

## 代价定义机制

### 宏生成模式

大多数计划节点通过宏 `define_plan_node!` 统一生成，该宏自动：

1. 在结构体中添加 `cost: f64` 字段
2. 生成 `cost()` 访问方法
3. 在克隆时保持代价值不变

### 手动实现节点

部分复杂节点（如连接节点、遍历节点）手动实现，但同样遵循统一模式：

- 结构体中包含 `cost: f64` 字段
- 在构造函数中初始化为 0.0
- 提供 `cost()` 方法返回代价值

---

## 当前问题分析

### 1. 代价恒为零

**问题描述**：
所有数据查询节点（扫描、过滤、连接、遍历等）的代价都初始化为 0.0，且运行时不更新。

**影响**：
- 优化器无法区分不同操作的实际成本差异
- 全表扫描和索引扫描在代价上无区别
- 嵌套循环连接和哈希连接无法基于代价选择
- 计划选择实际上退化为规则-based 而非代价-based

### 2. 缺乏统计信息集成

**问题描述**：
当前没有与存储层统计信息集成的机制。

**缺失的统计信息**：
- 表的行数估计
- 索引的选择性
- 列值的分布情况
- 数据页面的数量

**影响**：
- 无法基于表大小估算扫描代价
- 无法基于索引选择性选择最优索引
- 连接算法选择缺乏数据支持

### 3. 无选择性估计

**问题描述**：
没有实现条件选择性的估计机制。

**缺失的能力**：
- 无法估计过滤条件后的结果行数
- 无法估计连接操作的输出行数
- 无法区分高选择性和低选择性条件

**影响**：
- 过滤操作的成本与过滤条件复杂度无关
- 连接顺序选择缺乏依据
- 计划代价估算与实际执行偏差大

### 4. 缓存代价计算粗糙

**问题描述**：
查询计划缓存使用简单的节点数乘以固定系数作为代价：

```
estimated_cost = node_count × 100.0
```

**问题**：
- 与节点实际代价无关（所有节点实际代价为 0）
- 无法反映不同查询类型的真实成本差异
- 缓存淘汰策略缺乏有效依据

### 5. 代价模型与优化器脱节

**问题描述**：
虽然优化器规则（如集合操作输入顺序优化）尝试读取节点代价，但由于所有节点返回 0.0，实际无法发挥代价比较的作用。

**具体表现**：
- `estimate_node_cost` 函数递归读取节点代价，但所有基础节点返回 0.0
- 连接优化规则无法基于代价选择连接策略
- 索引选择缺乏代价依据

---

## 对系统的影响

### 查询优化层面

1. **计划选择质量下降**：无法选择真正最优的执行计划
2. **索引使用不足**：无法基于代价选择索引扫描而非全表扫描
3. **连接顺序随机**：缺乏数据支持的连接顺序选择

### 查询缓存层面

1. **缓存效率低下**：基于节点数的代价无法有效区分查询复杂度
2. **缓存污染**：简单查询和复杂查询可能获得相似代价评分

### 系统可扩展性

1. **无法支持自适应优化**：缺乏执行反馈机制
2. **难以支持复杂查询**：图遍历等复杂操作缺乏代价指导

---

## 总结

当前 GraphDB 的代价模型处于"占位符"状态，虽然具备代价模型的框架结构（每个节点有 cost 字段和 cost() 方法），但缺乏实际的代价计算逻辑和统计信息支持。这导致查询优化器无法发挥代价-based 优化的优势，计划选择主要依赖规则而非数据驱动的代价估算。

改进的关键在于：
1. 引入统计信息收集机制
2. 实现基于操作类型的基础代价计算
3. 建立选择性估计框架
4. 将代价模型与优化器规则深度集成

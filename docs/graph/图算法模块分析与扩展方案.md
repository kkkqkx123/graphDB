# 图算法模块分析与扩展方案

## 概述

通过检查`src/services/algorithm/graph.rs`，我们发现graphDB已经包含了相当完整的图算法实现。本报告将分析现有功能并提出扩展方案。

## 现有功能分析

### 已实现的图算法

1. **遍历算法**
   - 广度优先搜索（BFS）最短路径算法
   - 深度优先搜索（DFS）查找所有路径
   - 深度优先搜索收集连通分量

2. **图结构分析算法**
   - 连通分量查找
   - 有向图环检测
   - 拓扑排序
   - 强连通分量（使用Kosaraju算法）

3. **最短路径算法**
   - Dijkstra算法（适用于带权图）

### 算法实现质量评估

**优点：**
- 实现了基本的图算法
- 具有适当的单元测试
- 使用了合适的数据结构
- 考虑了性能边界条件（如最大深度限制）

**不足：**
- 缺少A*等启发式搜索算法
- 缺少Floyd-Warshall等多源最短路径算法
- 未针对实际图数据库数据结构优化
- 缺少图分析算法（如中心性计算）

## 需要扩展的功能

### 1. 更多最短路径算法

**A*搜索算法**
```rust
impl GraphAlgorithms {
    /// A* 算法实现，需要启发式函数
    pub fn a_star<T, F>(
        graph: &HashMap<T, Vec<(T, u32)>>, 
        start: &T, 
        goal: &T, 
        heuristic: F,  // 启发式函数
    ) -> Option<Vec<T>> 
    where 
        T: Clone + Eq + Hash + std::fmt::Debug,
        F: Fn(&T, &T) -> u32,
    {
        // A* 算法实现
        todo!()
    }
    
    /// Floyd-Warshall算法，用于多源最短路径
    pub fn floyd_warshall<T: Clone + Eq + Hash + Ord>(
        graph: &HashMap<T, Vec<(T, u32)>>,
    ) -> HashMap<(T, T), u32> {
        // Floyd-Warshall 算法实现
        todo!()
    }
    
    /// Bellman-Ford算法，支持负权边
    pub fn bellman_ford<T: Clone + Eq + Hash>(
        graph: &HashMap<T, Vec<(T, i32)>>,  // 注意是 i32 权重
        start: &T,
    ) -> Result<HashMap<T, i32>, String> {
        // Bellman-Ford 算法实现
        todo!()
    }
}
```

### 2. 图分析算法

**中心性算法**
```rust
impl GraphAlgorithms {
    /// 计算节点的度中心性
    pub fn degree_centrality<T: Clone + Eq + Hash>(
        graph: &HashMap<T, Vec<T>>,
    ) -> HashMap<T, f64> {
        let mut centrality = HashMap::new();
        let total_nodes = graph.len() as f64;
        
        for (node, neighbors) in graph {
            let centrality_value = neighbors.len() as f64 / (total_nodes - 1.0);
            centrality.insert(node.clone(), centrality_value);
        }
        
        centrality
    }
    
    /// 计算节点的接近中心性
    pub fn closeness_centrality<T: Clone + Eq + Hash + std::fmt::Debug>(
        graph: &HashMap<T, Vec<T>>,
    ) -> HashMap<T, f64> {
        let mut centrality = HashMap::new();
        
        for (node, _) in graph {
            let distances = Self::bfs_distances(graph, node);
            let sum_distances: f64 = distances.values().map(|&d| d as f64).sum();
            
            if sum_distances > 0.0 {
                let closeness = (distances.len() - 1) as f64 / sum_distances;
                centrality.insert(node.clone(), closeness);
            } else {
                centrality.insert(node.clone(), 0.0);
            }
        }
        
        centrality
    }
    
    /// 计算节点的介数中心性（Betweenness Centrality）
    pub fn betweenness_centrality<T: Clone + Eq + Hash + Ord>(
        graph: &HashMap<T, Vec<T>>,
    ) -> HashMap<T, f64> {
        let nodes: Vec<&T> = graph.keys().collect();
        let mut betweenness = HashMap::new();
        
        // 初始化 betweenness 值
        for node in &nodes {
            betweenness.insert((*node).clone(), 0.0);
        }
        
        // 对每个节点计算其作为最短路径中介的次数
        for s in &nodes {
            let mut stack = Vec::new();
            let mut predecessors: HashMap<&T, Vec<&T>> = HashMap::new();
            let mut distance: HashMap<&T, i32> = HashMap::new();
            let mut shortest_paths: HashMap<&T, f64> = HashMap::new();
            
            // 初始化
            for w in &nodes {
                predecessors.insert(w, Vec::new());
                distance.insert(w, -1);
                shortest_paths.insert(w, 0.0);
            }
            
            distance.insert(s, 0);
            shortest_paths.insert(s, 1.0);
            
            let mut queue = std::collections::VecDeque::new();
            queue.push_back(s);
            
            // BFS 阶段
            while let Some(v) = queue.pop_front() {
                stack.push(v);
                
                if let Some(neighbors) = graph.get(*v) {
                    for w in neighbors {
                        if *distance.get(&w).unwrap_or(&-1) < 0 {
                            queue.push_back(w);
                            *distance.get_mut(&w).unwrap() = distance.get(v).unwrap() + 1;
                        }
                        
                        if distance.get(w).unwrap() == &(distance.get(v).unwrap() + 1) {
                            *shortest_paths.get_mut(w).unwrap() += shortest_paths.get(v).unwrap();
                            predecessors.get_mut(w).unwrap().push(v);
                        }
                    }
                }
            }
            
            // 聚集依赖阶段
            let mut dependency: HashMap<&T, f64> = HashMap::new();
            for w in &nodes {
                dependency.insert(w, 0.0);
            }
            
            while let Some(w) = stack.pop() {
                for v in predecessors.get(w).unwrap() {
                    let val = shortest_paths.get(v).unwrap() / shortest_paths.get(w).unwrap() 
                           * (1.0 + dependency.get(w).unwrap());
                    *dependency.get_mut(v).unwrap() += val;
                }
                
                if w != s {
                    *betweenness.get_mut(w).unwrap() += dependency.get(w).unwrap();
                }
            }
        }
        
        // 归一化（对于无向图）
        let n = nodes.len() as f64;
        let n_factor = (n - 1.0) * (n - 2.0) / 2.0;
        for value in betweenness.values_mut() {
            *value /= n_factor;
        }
        
        betweenness
    }
    
    // 辅助方法：计算从源节点到所有节点的距离
    fn bfs_distances<T: Clone + Eq + Hash>(
        graph: &HashMap<T, Vec<T>>,
        start: &T,
    ) -> HashMap<T, u32> {
        let mut distances = HashMap::new();
        let mut queue = std::collections::VecDeque::new();
        let mut visited = std::collections::HashSet::new();
        
        queue.push_back((start.clone(), 0));
        visited.insert(start.clone());
        distances.insert(start.clone(), 0);
        
        while let Some((current, dist)) = queue.pop_front() {
            if let Some(neighbors) = graph.get(&current) {
                for neighbor in neighbors {
                    if !visited.contains(neighbor) {
                        visited.insert(neighbor.clone());
                        distances.insert(neighbor.clone(), dist + 1);
                        queue.push_back((neighbor.clone(), dist + 1));
                    }
                }
            }
        }
        
        distances
    }
}
```

### 3. 社区检测算法

**Louvain算法实现**
```rust
impl GraphAlgorithms {
    /// Louvain算法用于社区检测
    pub fn louvain_community_detection<T: Clone + Eq + Hash + Ord>(
        graph: &HashMap<T, Vec<(T, u32)>>,  // 加权图
    ) -> Vec<Vec<T>> {
        // Louvain算法实现
        todo!()
    }
}
```

### 4. 聚类系数算法

**局部和全局聚类系数**
```rust
impl GraphAlgorithms {
    /// 计算节点的局部聚类系数
    pub fn clustering_coefficient<T: Clone + Eq + Hash>(
        graph: &HashMap<T, Vec<T>>,
    ) -> HashMap<T, f64> {
        let mut clustering_coeffs = HashMap::new();
        
        for (node, neighbors) in graph {
            let neighbor_set: std::collections::HashSet<&T> = neighbors.iter().collect();
            let num_neighbors = neighbors.len();
            
            if num_neighbors < 2 {
                clustering_coeffs.insert(node.clone(), 0.0);
                continue;
            }
            
            let mut num_edges_between_neighbors = 0;
            
            // 计算邻居之间的边数
            for i in 0..neighbors.len() {
                for j in (i + 1)..neighbors.len() {
                    if neighbor_set.contains(&neighbors[i]) && 
                       graph.get(&neighbors[i])
                            .map_or(false, |n| n.contains(&neighbors[j])) {
                        num_edges_between_neighbors += 1;
                    }
                }
            }
            
            let coefficient = (2.0 * num_edges_between_neighbors as f64) / 
                             ((num_neighbors * (num_neighbors - 1)) as f64);
            clustering_coeffs.insert(node.clone(), coefficient);
        }
        
        clustering_coeffs
    }
}
```

### 5. 集成graphDB的图数据结构

**与graphDB数据模型的兼容性改进**
```rust
use crate::core::{Vertex, Edge, Value};
use std::collections::{HashMap, HashSet};

impl GraphAlgorithms {
    /// 使用graphDB的Vertex和Edge结构执行最短路径搜索
    pub fn shortest_path_with_vertices(
        vertices: &[Vertex],
        edges: &[Edge],
        start_id: &Value,
        target_id: &Value,
    ) -> Option<Vec<Vertex>> {
        // 构建邻接表
        let mut graph: HashMap<Value, Vec<Value>> = HashMap::new();
        let mut vertex_map: HashMap<Value, &Vertex> = HashMap::new();
        
        // 构建顶点映射
        for vertex in vertices {
            vertex_map.insert((*vertex.vid).clone(), vertex);
        }
        
        // 构建图结构
        for edge in edges {
            graph.entry(edge.src.clone())
                 .or_insert_with(Vec::new)
                 .push(edge.dst.clone());
        }
        
        // 使用BFS查找最短路径
        if let Some(path_ids) = Self::bfs_shortest_path(&graph, start_id, target_id) {
            // 将ID路径转换为顶点路径
            let mut path = Vec::new();
            for id in path_ids {
                if let Some(vertex) = vertex_map.get(&id) {
                    path.push((*vertex).clone());
                } else {
                    // 如果找不到ID对应的顶点，返回错误
                    return None;
                }
            }
            Some(path)
        } else {
            None
        }
    }

    /// 计算图的密度
    pub fn graph_density(vertices: &[Vertex], edges: &[Edge]) -> f64 {
        let num_vertices = vertices.len();
        let num_edges = edges.len();
        
        if num_vertices <= 1 {
            return 0.0;
        }
        
        // 对于有向图，最大边数是 n*(n-1)
        let max_possible_edges = num_vertices * (num_vertices - 1);
        (num_edges as f64) / (max_possible_edges as f64)
    }
    
    /// 检测孤立顶点
    pub fn find_isolated_vertices(vertices: &[Vertex], edges: &[Edge]) -> Vec<Vertex> {
        let mut connected_vertices = std::collections::HashSet::new();
        
        // 收集所有连接的顶点
        for edge in edges {
            connected_vertices.insert(&edge.src);
            connected_vertices.insert(&edge.dst);
        }
        
        // 找到没有边连接的顶点
        vertices.iter()
            .filter(|vertex| !connected_vertices.contains(&(*vertex.vid).clone()))
            .cloned()
            .collect()
    }
}
```

## 完善方案

1. **扩展现有的图算法**：如上所述，增加更多高级图算法

2. **优化与graphDB集成**：
   - 创建适配器将graphDB的Vertex和Edge结构转换为算法所需的格式
   - 直接在graphDB数据结构上运行算法，避免数据转换开销

3. **性能优化**：
   - 针对大图的算法优化
   - 提供并行版本的算法

4. **测试和验证**：
   - 为所有新算法添加单元测试
   - 创建集成测试验证算法在真实数据上的行为

## 影响评估

1. **功能增强**：添加了更多高级图算法
2. **性能**：某些算法可能会有计算开销，需要优化
3. **维护**：算法模块会变得更加丰富和复杂
4. **兼容性**：所有新功能都是可选的，不会影响现有代码
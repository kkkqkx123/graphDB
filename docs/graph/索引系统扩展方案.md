# 索引系统扩展方案

## 概述
当前的索引系统实现了标签索引、属性索引和复合索引，但缺少全文索引、地理空间索引等功能。本文档描述了扩展索引系统的方案。

## 需求分析

### 缺失功能
1. 全文索引
2. 地理空间索引
3. 复合索引优化
4. 索引统计和管理功能

## 详细方案

### 1. 全文索引

#### 文件: `src/graph/index/fulltext.rs`

```rust
use std::collections::{HashMap, HashSet, BTreeMap};
use crate::core::Value;

pub enum FullTextIndexError {
    CreationError(String),
    UpdateError(String),
    QueryError(String),
}

/// 全文索引，使用倒排索引结构
pub struct FullTextIndex {
    /// 词项 -> 文档ID集合的映射
    inverted_index: HashMap<String, HashSet<Value>>,
    /// 文档ID -> 内容的映射
    documents: HashMap<Value, String>,
    /// 文档长度统计（用于TF-IDF计算）
    doc_lengths: HashMap<Value, usize>,
}

impl FullTextIndex {
    pub fn new() -> Self {
        Self {
            inverted_index: HashMap::new(),
            documents: HashMap::new(),
            doc_lengths: HashMap::new(),
        }
    }

    /// 添加文档到索引
    pub fn insert(&mut self, doc_id: Value, content: &str) -> Result<(), FullTextIndexError> {
        // 首先从倒排索引中移除文档的旧内容
        if let Some(old_content) = self.documents.get(&doc_id) {
            self.remove_from_index(doc_id.clone(), old_content)?;
        }

        // 添加新内容
        self.documents.insert(doc_id.clone(), content.to_string());
        self.index_document(doc_id, content)?;
        Ok(())
    }

    /// 从索引中移除文档
    pub fn remove(&mut self, doc_id: &Value) -> Result<(), FullTextIndexError> {
        if let Some(content) = self.documents.remove(doc_id) {
            self.remove_from_index(doc_id.clone(), &content)?;
        }
        Ok(())
    }

    /// 搜索包含关键词的文档
    pub fn search(&self, query: &str) -> Vec<Value> {
        let keywords = self.tokenize(query);
        let mut doc_scores: HashMap<Value, u32> = HashMap::new();

        for keyword in keywords {
            if let Some(doc_ids) = self.inverted_index.get(&keyword) {
                for doc_id in doc_ids {
                    *doc_scores.entry(doc_id.clone()).or_insert(0) += 1;
                }
            }
        }

        // 按得分排序返回文档ID
        let mut scored_docs: Vec<(Value, u32)> = doc_scores.into_iter().collect();
        scored_docs.sort_by(|a, b| b.1.cmp(&a.1));
        scored_docs.into_iter().map(|(id, _)| id).collect()
    }

    /// 对文档进行分词并建立索引
    fn index_document(&mut self, doc_id: Value, content: &str) -> Result<(), FullTextIndexError> {
        let tokens = self.tokenize(content);
        let doc_length = tokens.len();
        self.doc_lengths.insert(doc_id.clone(), doc_length);

        for token in tokens {
            self.inverted_index
                .entry(token)
                .or_insert_with(HashSet::new)
                .insert(doc_id.clone());
        }

        Ok(())
    }

    /// 从索引中移除文档
    fn remove_from_index(&mut self, doc_id: Value, content: &str) -> Result<(), FullTextIndexError> {
        let tokens = self.tokenize(content);
        for token in tokens {
            if let Some(doc_ids) = self.inverted_index.get_mut(&token) {
                doc_ids.remove(&doc_id);
                // 如果词项对应的文档集合为空，则移除该词项
                if doc_ids.is_empty() {
                    self.inverted_index.remove(&token);
                }
            }
        }
        self.doc_lengths.remove(&doc_id);
        Ok(())
    }

    /// 简单的分词函数（在实际应用中可能需要更复杂的分词器）
    fn tokenize(&self, text: &str) -> Vec<String> {
        text.split_whitespace()
            .map(|s| s.to_lowercase())
            .collect()
    }
}
```

### 2. 地理空间索引

#### 文件: `src/graph/index/spatial.rs`

```rust
use std::collections::HashMap;
use crate::core::Value;

pub enum SpatialIndexError {
    CreationError(String),
    UpdateError(String),
    QueryError(String),
}

/// 地理坐标点
#[derive(Debug, Clone)]
pub struct Point {
    pub longitude: f64,  // 经度
    pub latitude: f64,   // 纬度
}

/// 地理空间索引，使用简单的基于距离的索引
pub struct SpatialIndex {
    points: HashMap<Value, Point>,
}

impl SpatialIndex {
    pub fn new() -> Self {
        Self {
            points: HashMap::new(),
        }
    }

    /// 添加地理点到索引
    pub fn insert(&mut self, id: Value, point: Point) -> Result<(), SpatialIndexError> {
        self.points.insert(id, point);
        Ok(())
    }

    /// 从索引中移除地理点
    pub fn remove(&mut self, id: &Value) -> Result<(), SpatialIndexError> {
        self.points.remove(id);
        Ok(())
    }

    /// 搜索指定距离内的点
    pub fn search_in_radius(&self, center: &Point, radius_meters: f64) -> Vec<(Value, f64)> {
        let mut results = Vec::new();
        for (id, point) in &self.points {
            let distance = self.haversine_distance(center, point);
            if distance <= radius_meters {
                results.push((id.clone(), distance));
            }
        }
        
        // 按距离排序
        results.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());
        results
    }

    /// 搜索指定矩形区域内的点
    pub fn search_in_bounding_box(&self, min_point: &Point, max_point: &Point) -> Vec<Value> {
        let mut results = Vec::new();
        for (id, point) in &self.points {
            if point.longitude >= min_point.longitude 
                && point.longitude <= max_point.longitude
                && point.latitude >= min_point.latitude
                && point.latitude <= max_point.latitude {
                results.push(id.clone());
            }
        }
        results
    }

    /// 计算两点间的距离（米）
    fn haversine_distance(&self, p1: &Point, p2: &Point) -> f64 {
        let earth_radius_meters = 6_371_000.0; // 地球半径（米）
        
        let lat1_rad = p1.latitude.to_radians();
        let lat2_rad = p2.latitude.to_radians();
        let delta_lat_rad = (p2.latitude - p1.latitude).to_radians();
        let delta_lon_rad = (p2.longitude - p1.longitude).to_radians();

        let a = (delta_lat_rad / 2.0).sin().powi(2)
            + lat1_rad.cos() * lat2_rad.cos() * (delta_lon_rad / 2.0).sin().powi(2);
        let c = 2.0 * a.sqrt().atan2((1.0 - a).sqrt());

        earth_radius_meters * c
    }
}
```

### 3. 索引管理器增强

#### 文件: `src/graph/index.rs` （增强版本）

```rust
use crate::core::{Value, Vertex};
use std::collections::{HashMap, HashSet};
use super::spatial::{SpatialIndex, SpatialIndexError, Point};
use super::fulltext::{FullTextIndex, FullTextIndexError};

#[derive(Debug)]
pub enum IndexError {
    IndexCreationError(String),
    IndexUpdateError(String),
    SpatialIndexError(SpatialIndexError),
    FullTextIndexError(FullTextIndexError),
}

/// 索引管理器
pub struct IndexManager {
    label_index: LabelIndex,
    property_index: PropertyIndex,
    composite_index: CompositeIndex,
    spatial_index: SpatialIndex,      // 新增：地理空间索引
    fulltext_index: FullTextIndex,    // 新增：全文索引
}

impl IndexManager {
    pub fn new() -> Self {
        Self {
            label_index: LabelIndex::new(),
            property_index: PropertyIndex::new(),
            composite_index: CompositeIndex::new(),
            spatial_index: SpatialIndex::new(),
            fulltext_index: FullTextIndex::new(),
        }
    }

    /// 更新所有相关索引以包含新的顶点
    pub fn update_indexes_for_node(&mut self, vertex: &Vertex) -> Result<(), IndexError> {
        // 原有的标签和属性索引更新
        for tag in &vertex.tags {
            self.label_index
                .insert(tag.name.clone(), (*vertex.vid).clone())
                .map_err(|e| IndexError::IndexUpdateError(e.to_string()))?;

            for (key, value) in &tag.properties {
                // 检查是否需要为特定属性建立空间索引
                if key.ends_with("_location") || key.ends_with("_point") {
                    if let Value::String(location_str) = value {
                        if let Ok((longitude, latitude)) = parse_location_string(location_str) {
                            let point = Point { longitude, latitude };
                            self.spatial_index
                                .insert((*vertex.vid).clone(), point)
                                .map_err(|e| IndexError::SpatialIndexError(e))?;
                        }
                    }
                }
                // 检查是否需要为特定属性建立全文索引
                else if key.ends_with("_description") || key.ends_with("_content") {
                    if let Value::String(content) = value {
                        self.fulltext_index
                            .insert((*vertex.vid).clone(), content)
                            .map_err(|e| IndexError::FullTextIndexError(e))?;
                    }
                }
                
                self.property_index
                    .insert(key.clone(), value.clone(), (*vertex.vid).clone())
                    .map_err(|e| IndexError::IndexUpdateError(e.to_string()))?;
                self.composite_index
                    .insert(key.clone(), value.clone(), (*vertex.vid).clone())
                    .map_err(|e| IndexError::IndexUpdateError(e.to_string()))?;
            }
        }

        Ok(())
    }

    /// 从所有相关索引中移除顶点
    pub fn remove_indexes_for_node(&mut self, vertex: &Vertex) -> Result<(), IndexError> {
        // 原有的标签和属性索引更新
        for tag in &vertex.tags {
            self.label_index
                .remove(&tag.name, &(*vertex.vid))
                .map_err(|e| IndexError::IndexUpdateError(e.to_string()))?;

            for (key, value) in &tag.properties {
                self.property_index
                    .remove(key, value, &(*vertex.vid))
                    .map_err(|e| IndexError::IndexUpdateError(e.to_string()))?;
                self.composite_index
                    .remove(key, value, &(*vertex.vid))
                    .map_err(|e| IndexError::IndexUpdateError(e.to_string()))?;
                
                // 同时从空间索引和全文索引中移除
                if key.ends_with("_location") || key.ends_with("_point") {
                    self.spatial_index
                        .remove(&(*vertex.vid))
                        .map_err(|e| IndexError::SpatialIndexError(e))?;
                } else if key.ends_with("_description") || key.ends_with("_content") {
                    self.fulltext_index
                        .remove(&(*vertex.vid))
                        .map_err(|e| IndexError::FullTextIndexError(e))?;
                }
            }
        }

        Ok(())
    }

    // 空间查询方法
    pub fn search_spatial(&self, center: &Point, radius_meters: f64) -> Vec<(Value, f64)> {
        self.spatial_index.search_in_radius(center, radius_meters)
    }

    pub fn search_bounding_box(&self, min_point: &Point, max_point: &Point) -> Vec<Value> {
        self.spatial_index.search_in_bounding_box(min_point, max_point)
    }

    // 全文搜索方法
    pub fn search_fulltext(&self, query: &str) -> Vec<Value> {
        self.fulltext_index.search(query)
    }

    // 现有的索引查询方法
    pub fn get_nodes_by_label(&self, label: &str) -> Option<&HashSet<Value>> {
        self.label_index.get_nodes_by_label(label)
    }

    pub fn get_nodes_by_property(
        &self,
        property_name: &str,
        value: &Value,
    ) -> Option<&HashSet<Value>> {
        self.property_index
            .get_nodes_by_property(property_name, value)
    }
}

/// 解析位置字符串，返回经度和纬度
fn parse_location_string(location_str: &str) -> Result<(f64, f64), ()> {
    let parts: Vec<&str> = location_str.split(',').collect();
    if parts.len() == 2 {
        let longitude = parts[0].trim().parse::<f64>().map_err(|_| ())?;
        let latitude = parts[1].trim().parse::<f64>().map_err(|_| ())?;
        Ok((longitude, latitude))
    } else {
        Err(())
    }
}
```

### 4. 索引统计和管理功能

#### 文件: `src/graph/index/stats.rs`

```rust
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub struct IndexStats {
    pub total_indexes: usize,
    pub label_index_count: usize,
    pub property_index_count: usize,
    pub fulltext_index_count: usize,
    pub spatial_index_count: usize,
    pub total_entries: usize,
    pub memory_usage_bytes: usize,
}

pub struct IndexStatsManager {
    stats: IndexStats,
    index_details: HashMap<String, IndexDetail>,
}

#[derive(Debug, Clone)]
pub struct IndexDetail {
    pub name: String,
    pub index_type: String,
    pub entry_count: usize,
    pub memory_usage_bytes: usize,
}

impl IndexStatsManager {
    pub fn new() -> Self {
        Self {
            stats: IndexStats {
                total_indexes: 0,
                label_index_count: 0,
                property_index_count: 0,
                fulltext_index_count: 0,
                spatial_index_count: 0,
                total_entries: 0,
                memory_usage_bytes: 0,
            },
            index_details: HashMap::new(),
        }
    }

    pub fn update_stats(&mut self, index_manager: &IndexManager) {
        // 计算统计信息，这在实际实现中需要访问各个索引的内部结构
        // 此处仅为示例，实际实现需根据各索引结构调整
        self.stats = IndexStats {
            total_indexes: 5, // 标签、属性、复合、全文、空间索引
            label_index_count: index_manager.label_index.count(), // 需要实现count方法
            property_index_count: index_manager.property_index.count(), // 需要实现count方法
            fulltext_index_count: index_manager.fulltext_index.count(), // 需要实现count方法
            spatial_index_count: index_manager.spatial_index.count(), // 需要实现count方法
            total_entries: 0, // 需要实现entry_count方法
            memory_usage_bytes: 0, // 需要实现memory_usage方法
        };
    }

    pub fn get_stats(&self) -> &IndexStats {
        &self.stats
    }
}
```

## 测试方案

### 集成测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::{Value, Vertex, Tag};

    #[test]
    fn test_fulltext_index() {
        let mut index = FullTextIndex::new();
        
        // 插入文档
        let doc1_id = Value::Int(1);
        let doc2_id = Value::Int(2);
        index.insert(doc1_id.clone(), "Rust programming language").unwrap();
        index.insert(doc2_id.clone(), "Graph database implementation").unwrap();
        
        // 搜索
        let results = index.search("rust");
        assert!(results.contains(&doc1_id));
    }

    #[test]
    fn test_spatial_index() {
        let mut index = SpatialIndex::new();
        
        // 插入点
        let point1 = Point { longitude: 0.0, latitude: 0.0 };
        let point2 = Point { longitude: 1.0, latitude: 1.0 };
        index.insert(Value::Int(1), point1).unwrap();
        index.insert(Value::Int(2), point2).unwrap();
        
        // 搜索半径内的点
        let center = Point { longitude: 0.0, latitude: 0.0 };
        let results = index.search_in_radius(&center, 200_000.0); // 200km半径
        assert!(results.iter().any(|(id, _)| *id == Value::Int(1)));
    }

    #[test]
    fn test_index_manager_with_enhanced_indexes() {
        let mut index_manager = IndexManager::new();
        
        // 创建一个带有空间和文本属性的顶点
        let properties = [
            ("name".to_string(), Value::String("Test Place".to_string())),
            ("location".to_string(), Value::String("0.0,0.0".to_string())), // 空间属性
            ("description".to_string(), Value::String("A beautiful place for testing".to_string())), // 文本属性
        ].iter().cloned().collect();
        
        let tag = Tag::new("Place".to_string(), properties);
        let vertex = Vertex::new(Value::Int(1), vec![tag]);
        
        // 更新索引
        index_manager.update_indexes_for_node(&vertex).unwrap();
        
        // 验证空间索引
        let center = Point { longitude: 0.0, latitude: 0.0 };
        let spatial_results = index_manager.search_spatial(&center, 1000.0);
        assert!(spatial_results.iter().any(|(id, _)| *id == Value::Int(1)));
        
        // 验证全文索引
        let text_results = index_manager.search_fulltext("beautiful");
        assert!(text_results.contains(&Value::Int(1)));
    }
}
```

## 影响评估

1. 功能增强：支持全文搜索和地理空间查询
2. 性能：新的索引类型会增加内存使用，但显著提高特定查询的性能
3. 维护：索引系统将变得更加复杂，需要更仔细的维护
4. 兼容性：扩展是对现有功能的增加，不影响现有功能
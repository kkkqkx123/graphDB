# 错误处理完善方案

## 概述
当前的错误处理在各个模块中是分散的，缺少统一的错误处理框架。本文档描述了完善错误处理系统的方案。

## 需求分析

### 缺失功能
1. 统一的错误处理框架
2. 详细的错误码定义
3. 错误链追踪
4. 结构化错误日志

## 详细方案

### 1. 统一错误类型定义

#### 文件: `src/core/error.rs`

```rust
use thiserror::Error;
use std::fmt;

/// 图数据库统一错误类型
#[derive(Error, Debug)]
pub enum GraphDBError {
    /// 存储错误
    #[error("Storage error: {0}")]
    StorageError(#[from] crate::storage::StorageError),
    
    /// 查询错误
    #[error("Query error: {0}")]
    QueryError(#[from] crate::query::QueryError),
    
    /// 图算法错误
    #[error("Algorithm error: {0}")]
    AlgorithmError(String),
    
    /// 事务错误
    #[error("Transaction error: {0}")]
    TransactionError(#[from] crate::graph::transaction::error::TransactionError),
    
    /// 索引错误
    #[error("Index error: {0}")]
    IndexError(String),
    
    /// 配置错误
    #[error("Configuration error: {0}")]
    ConfigError(String),
    
    /// 网络错误
    #[error("Network error: {0}")]
    NetworkError(String),
    
    /// 权限错误
    #[error("Permission denied: {0}")]
    PermissionError(String),
    
    /// 资源限制错误
    #[error("Resource limit exceeded: {0}")]
    ResourceLimitError(String),
    
    /// 输入输出错误
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
    
    /// 序列化错误
    #[error("Serialization error: {0}")]
    SerializationError(#[from] serde_json::Error),
    
    /// 未知错误
    #[error("Unknown error: {0}")]
    UnknownError(String),
}

/// 错误码定义
#[derive(Debug, Clone, Copy)]
pub enum ErrorCode {
    // 通用错误码
    OK = 0,
    UNKNOWN_ERROR = 1001,
    INVALID_ARGUMENT = 1002,
    PERMISSION_DENIED = 1003,
    RESOURCE_EXHAUSTED = 1004,
    UNAVAILABLE = 1005,
    
    // 存储相关错误码
    STORAGE_ERROR = 2001,
    STORAGE_NOT_FOUND = 2002,
    STORAGE_DUPLICATE_KEY = 2003,
    STORAGE_CORRUPTION = 2004,
    
    // 查询相关错误码
    SYNTAX_ERROR = 3001,
    SEMANTIC_ERROR = 3002,
    EXECUTION_ERROR = 3003,
    TIMEOUT_ERROR = 3004,
    
    // 事务相关错误码
    TXN_CONFLICT = 4001,
    TXN_ABORTED = 4002,
    TXN_NOT_FOUND = 4003,
    
    // 索引相关错误码
    INDEX_ERROR = 5001,
    INDEX_DUPLICATE = 5002,
    INDEX_NOT_FOUND = 5003,
}

impl fmt::Display for ErrorCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// 标准错误响应结构
#[derive(Debug, Serialize, Deserialize)]
pub struct GraphDBResult<T> {
    pub code: ErrorCode,
    pub message: String,
    pub data: Option<T>,
}

impl<T> GraphDBResult<T> {
    pub fn success(data: T) -> Self {
        Self {
            code: ErrorCode::OK,
            message: "Success".to_string(),
            data: Some(data),
        }
    }
    
    pub fn error(code: ErrorCode, message: String) -> Self {
        Self {
            code,
            message,
            data: None,
        }
    }
    
    pub fn from_error(error: GraphDBError) -> Self {
        let (code, message) = Self::map_error_to_code(&error);
        Self {
            code,
            message,
            data: None,
        }
    }
    
    fn map_error_to_code(error: &GraphDBError) -> (ErrorCode, String) {
        match error {
            GraphDBError::StorageError(e) => {
                use crate::storage::StorageError as SE;
                match e {
                    SE::NodeNotFound(_) => (ErrorCode::STORAGE_NOT_FOUND, format!("Storage error: {}", e)),
                    SE::EdgeNotFound(_) => (ErrorCode::STORAGE_NOT_FOUND, format!("Storage error: {}", e)),
                    SE::SerializationError(_) => (ErrorCode::STORAGE_ERROR, format!("Storage error: {}", e)),
                    _ => (ErrorCode::STORAGE_ERROR, format!("Storage error: {}", e)),
                }
            },
            GraphDBError::QueryError(e) => {
                use crate::query::QueryError as QE;
                match e {
                    QE::StorageError(_) => (ErrorCode::STORAGE_ERROR, format!("Query error: {}", e)),
                    QE::ParseError(_) => (ErrorCode::SYNTAX_ERROR, format!("Query error: {}", e)),
                    QE::InvalidQuery(_) => (ErrorCode::SEMANTIC_ERROR, format!("Query error: {}", e)),
                    QE::ExecutionError(_) => (ErrorCode::EXECUTION_ERROR, format!("Query error: {}", e)),
                    QE::ExpressionError(_) => (ErrorCode::EXECUTION_ERROR, format!("Query error: {}", e)),
                }
            },
            GraphDBError::TransactionError(e) => {
                use crate::graph::transaction::error::TransactionError as TE;
                match e {
                    TE::TransactionNotFound(_) => (ErrorCode::TXN_NOT_FOUND, format!("Transaction error: {}", e)),
                    TE::InvalidState(_) => (ErrorCode::TXN_ABORTED, format!("Transaction error: {}", e)),
                    TE::StorageError(_) => (ErrorCode::STORAGE_ERROR, format!("Transaction error: {}", e)),
                    TE::LockError(_) => (ErrorCode::TXN_CONFLICT, format!("Transaction error: {}", e)),
                    TE::SerializationError(_) => (ErrorCode::TXN_ABORTED, format!("Transaction error: {}", e)),
                    TE::Timeout => (ErrorCode::TIMEOUT_ERROR, format!("Transaction error: {}", e)),
                    TE::Deadlock => (ErrorCode::TXN_CONFLICT, format!("Transaction error: {}", e)),
                }
            },
            _ => (ErrorCode::UNKNOWN_ERROR, format!("{}", error)),
        }
    }
}
```

### 2. 错误追踪和日志

#### 文件: `src/core/tracing.rs`

```rust
use tracing::{error, warn, info, debug, event, span, Level};
use tracing_subscriber::{FmtSubscriber, EnvFilter};
use std::sync::Once;

static INIT: Once = Once::new();

pub fn init_tracing() {
    INIT.call_once(|| {
        let subscriber = FmtSubscriber::builder()
            .with_env_filter(EnvFilter::from_default_env())
            .with_line_number(true)
            .with_file(true)
            .finish();
        
        tracing::subscriber::set_global_default(subscriber)
            .expect("Setting default subscriber failed");
    });
}

/// 创建带错误追踪的错误类型
#[derive(Debug)]
pub struct TracedError {
    pub error: crate::core::GraphDBError,
    pub backtrace: std::backtrace::Backtrace,
    pub context: Vec<String>, // 错误上下文
}

impl TracedError {
    pub fn new(error: crate::core::GraphDBError) -> Self {
        Self {
            error,
            backtrace: std::backtrace::Backtrace::force_capture(),
            context: Vec::new(),
        }
    }
    
    pub fn add_context<S: AsRef<str>>(mut self, context: S) -> Self {
        self.context.push(context.as_ref().to_string());
        self
    }
    
    pub fn log_error(&self) {
        error!(
            error = ?self.error,
            backtrace = %self.backtrace,
            context = ?self.context,
            "Traced error occurred"
        );
    }
}

impl std::fmt::Display for TracedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "Error: {}", self.error)?;
        if !self.context.is_empty() {
            writeln!(f, "Context:")?;
            for ctx in &self.context {
                writeln!(f, "  - {}", ctx)?;
            }
        }
        Ok(())
    }
}

impl std::error::Error for TracedError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        Some(&self.error)
    }
}
```

### 3. 错误处理中间件

#### 文件: `src/api/middleware/error_handler.rs`

```rust
use crate::core::{GraphDBError, GraphDBResult, ErrorCode};
use axum::{
    response::{IntoResponse, Response},
    http::StatusCode,
    Json,
};
use serde_json::json;

pub async fn handle_error(error: GraphDBError) -> impl IntoResponse {
    let result: GraphDBResult<()> = GraphDBResult::from_error(error);
    
    let status_code = match result.code {
        ErrorCode::OK => StatusCode::OK,
        ErrorCode::PERMISSION_DENIED => StatusCode::FORBIDDEN,
        ErrorCode::RESOURCE_EXHAUSTED => StatusCode::TOO_MANY_REQUESTS,
        ErrorCode::TIMEOUT_ERROR => StatusCode::REQUEST_TIMEOUT,
        _ => StatusCode::INTERNAL_SERVER_ERROR,
    };
    
    let body = Json(json!({
        "code": result.code as u16,
        "message": result.message,
        "timestamp": chrono::Utc::now().to_rfc3339(),
    }));
    
    (status_code, body)
}

/// 错误响应包装器
pub fn wrap_error<T>(result: Result<T, GraphDBError>) -> Result<GraphDBResult<T>, GraphDBError> {
    match result {
        Ok(value) => Ok(GraphDBResult::success(value)),
        Err(error) => {
            let graph_result: GraphDBResult<T> = GraphDBResult::from_error(error.clone());
            Err(error) // 返回原始错误，以便上层处理
        }
    }
}
```

### 4. 模块化错误处理

#### 文件: 在各个模块中添加错误处理

```rust
// 在src/storage/error.rs中
#[derive(Error, Debug, Clone)]
pub enum StorageError {
    #[error("Node not found: {0:?}")]
    NodeNotFound(crate::core::Value),
    #[error("Edge not found: {0:?}")]
    EdgeNotFound(crate::core::Value),
    #[error("Serialization error: {0}")]
    SerializationError(String),
    #[error("IO error: {0}")]
    IoError(String),
    #[error("Database corruption: {0}")]
    Corruption(String),
    #[error("Constraint violation: {0}")]
    ConstraintViolation(String),
}

// 在src/query/error.rs中
#[derive(Error, Debug, Clone)]
pub enum QueryError {
    #[error("Storage error: {0}")]
    StorageError(#[from] StorageError),
    #[error("Parse error: {0}")]
    ParseError(String),
    #[error("Invalid query: {0}")]
    InvalidQuery(String),
    #[error("Execution error: {0}")]
    ExecutionError(String),
    #[error("Expression error: {0}")]
    ExpressionError(String),
    #[error("Timeout error: {0}")]
    Timeout(String),
    #[error("Not implemented: {0}")]
    NotImplemented(String),
}
```

### 5. 全局错误处理配置

#### 文件: `src/main.rs` 或 `src/lib.rs`

```rust
use crate::core::{init_tracing, GraphDBError, TracedError};

pub fn setup_error_handling() {
    // 初始化追踪系统
    init_tracing();
    
    // 设置自定义 panic hook
    std::panic::set_hook(Box::new(|panic_info| {
        error!(
            "Panic occurred: {:?}\n{:?}", 
            panic_info,
            std::backtrace::Backtrace::force_capture()
        );
    }));
}

/// 通用错误处理宏
#[macro_export]
macro_rules! handle_error {
    ($result:expr) => {
        match $result {
            Ok(val) => val,
            Err(e) => {
                let traced_error = TracedError::new(e.into())
                    .add_context(format!("At {}:{}:{}", file!(), line!(), column!()));
                traced_error.log_error();
                return Err(traced_error.error);
            }
        }
    };
}
```

## 测试方案

### 集成测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::{GraphDBError, GraphDBResult, ErrorCode};

    #[test]
    fn test_error_code_mapping() {
        let storage_error = GraphDBError::StorageError(
            crate::storage::StorageError::NodeNotFound(crate::core::Value::Int(1))
        );
        let result = GraphDBResult::<()>::from_error(storage_error);
        assert_eq!(result.code, ErrorCode::STORAGE_NOT_FOUND);
    }

    #[test]
    fn test_traced_error() {
        let error = GraphDBError::UnknownError("Test error".to_string());
        let traced_error = TracedError::new(error)
            .add_context("Test context");
        
        assert_eq!(traced_error.context.len(), 1);
        assert_eq!(traced_error.context[0], "Test context");
    }

    #[test]
    fn test_error_response() {
        let error = GraphDBError::ConfigError("Invalid configuration".to_string());
        let result: GraphDBResult<()> = GraphDBResult::from_error(error);
        
        assert_eq!(result.code, ErrorCode::UNKNOWN_ERROR);
        assert!(result.message.contains("Invalid configuration"));
        assert!(result.data.is_none());
    }
}
```

## 影响评估

1. **功能增强**：提供统一、结构化的错误处理机制
2. **性能**：错误追踪会引入一些性能开销，但可以通过配置控制
3. **维护**：错误处理变得更加一致和易于调试
4. **兼容性**：向后兼容，现有错误类型可映射到新的错误系统
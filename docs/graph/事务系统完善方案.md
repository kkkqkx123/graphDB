# 事务系统完善方案

## 概述
当前的事务系统定义了基本的事务结构和操作，但没有与存储引擎集成，缺少实际的事务执行和回滚机制。本文档描述了完善事务系统的方案。

## 需求分析

### 缺失功能
1. 事务与存储引擎集成
2. 事务隔离级别定义
3. 事务回滚的数据恢复机制
4. 事务状态管理和并发控制

## 详细方案

### 1. 事务隔离级别定义

#### 文件: `src/graph/transaction/isolation.rs`

```rust
/// 事务隔离级别
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum IsolationLevel {
    /// 读未提交
    ReadUncommitted,
    /// 读已提交
    ReadCommitted,
    /// 可重复读
    RepeatableRead,
    /// 串行化
    Serializable,
}

impl Default for IsolationLevel {
    fn default() -> Self {
        IsolationLevel::ReadCommitted
    }
}
```

### 2. 事务上下文和状态

#### 文件: `src/graph/transaction/context.rs`

```rust
use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
use std::sync::{Arc, Mutex};
use std::collections::{HashMap, HashSet};
use crate::core::{Value, Vertex, Edge};
use crate::storage::StorageEngine;
use super::{IsolationLevel, TransactionError, Operation};

/// 事务状态
#[derive(Debug, Clone, PartialEq)]
pub enum TransactionState {
    Active,
    Committed,
    RolledBack,
    Failed,
}

/// 事务上下文，包含事务相关的状态
pub struct TransactionContext {
    /// 事务ID
    id: u64,
    /// 事务状态
    state: TransactionState,
    /// 隔离级别
    isolation_level: IsolationLevel,
    /// 事务操作列表
    operations: Vec<Operation>,
    /// 事务开始时间
    start_time: std::time::Instant,
    /// 在事务中修改的数据
    modified_data: HashMap<Value, Option<Vertex>>, // 存储旧值用于回滚
    /// 在事务中读取的数据，用于实现隔离级别
    read_set: HashSet<Value>,
    /// 在事务中写入的数据
    write_set: HashSet<Value>,
}

impl TransactionContext {
    pub fn new(id: u64, isolation_level: IsolationLevel) -> Self {
        Self {
            id,
            state: TransactionState::Active,
            isolation_level,
            operations: Vec::new(),
            start_time: std::time::Instant::now(),
            modified_data: HashMap::new(),
            read_set: HashSet::new(),
            write_set: HashSet::new(),
        }
    }

    /// 检查事务是否处于活动状态
    pub fn is_active(&self) -> bool {
        matches!(self.state, TransactionState::Active)
    }

    /// 检查事务是否已提交
    pub fn is_committed(&self) -> bool {
        matches!(self.state, TransactionState::Committed)
    }

    /// 检查事务是否已回滚
    pub fn is_rolled_back(&self) -> bool {
        matches!(self.state, TransactionState::RolledBack)
    }

    /// 添加读取记录
    pub fn add_read_record(&mut self, key: Value) {
        self.read_set.insert(key);
    }

    /// 添加写入记录
    pub fn add_write_record(&mut self, key: Value) {
        self.write_set.insert(key);
    }

    /// 获取写入集合
    pub fn get_write_set(&self) -> &HashSet<Value> {
        &self.write_set
    }

    /// 添加操作到事务
    pub fn add_operation(&mut self, operation: Operation) -> Result<(), TransactionError> {
        if !self.is_active() {
            return Err(TransactionError::InvalidState(self.id));
        }

        self.operations.push(operation);
        Ok(())
    }
}
```

### 3. 事务与存储引擎集成

#### 文件: `src/graph/transaction/manager.rs` （扩展版本）

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use crate::core::{Value, Vertex, Edge};
use crate::storage::{StorageEngine, StorageError};
use super::{TransactionContext, TransactionState, IsolationLevel, TransactionError, Operation};

pub struct TransactionManager<S: StorageEngine> {
    current_tx_id: AtomicU64,
    active_transactions: Arc<Mutex<HashMap<u64, TransactionContext>>>,
    storage: Arc<Mutex<S>>,
}

impl<S: StorageEngine> TransactionManager<S> {
    pub fn new(storage: Arc<Mutex<S>>) -> Self {
        Self {
            current_tx_id: AtomicU64::new(1),
            active_transactions: Arc::new(Mutex::new(HashMap::new())),
            storage,
        }
    }

    /// 开始一个新的事务
    pub fn begin_transaction(&self, isolation_level: IsolationLevel) -> Result<u64, TransactionError> {
        let tx_id = self.current_tx_id.fetch_add(1, Ordering::SeqCst);
        let mut transactions = self.active_transactions.lock()
            .map_err(|_| TransactionError::LockError("Failed to acquire lock".to_string()))?;
        
        let context = TransactionContext::new(tx_id, isolation_level);
        transactions.insert(tx_id, context);
        Ok(tx_id)
    }

    /// 获取事务上下文
    fn get_transaction_context(&self, tx_id: u64) -> Result<TransactionContext, TransactionError> {
        let transactions = self.active_transactions.lock()
            .map_err(|_| TransactionError::LockError("Failed to acquire lock".to_string()))?;
        transactions.get(&tx_id)
            .cloned()
            .ok_or(TransactionError::TransactionNotFound(tx_id))
    }

    /// 更新事务上下文
    fn update_transaction_context<F>(&self, tx_id: u64, f: F) -> Result<(), TransactionError>
    where
        F: FnOnce(&mut TransactionContext) -> Result<(), TransactionError>,
    {
        let mut transactions = self.active_transactions.lock()
            .map_err(|_| TransactionError::LockError("Failed to acquire lock".to_string()))?;
        let context = transactions.get_mut(&tx_id)
            .ok_or(TransactionError::TransactionNotFound(tx_id))?;
        f(context)
    }

    /// 在事务上下文中读取节点
    pub fn get_node_in_tx(&self, tx_id: u64, id: &Value) -> Result<Option<Vertex>, TransactionError> {
        let mut transactions = self.active_transactions.lock()
            .map_err(|_| TransactionError::LockError("Failed to acquire lock".to_string()))?;
        let context = transactions.get_mut(&tx_id)
            .ok_or(TransactionError::TransactionNotFound(tx_id))?;

        if !context.is_active() {
            return Err(TransactionError::InvalidState(tx_id));
        }

        // 根据隔离级别检查是否可以读取
        match context.isolation_level {
            IsolationLevel::Serializable | IsolationLevel::RepeatableRead => {
                // 检查是否存在写偏序冲突
                if context.write_set.contains(id) {
                    // 正在写入，返回事务内版本
                    if let Some(Some(vertex)) = context.modified_data.get(id) {
                        return Ok(Some(vertex.clone()));
                    } else if let Some(None) = context.modified_data.get(id) {
                        return Ok(None); // 已标记删除
                    }
                }
            }
            _ => {}
        }

        // 添加到读取集
        context.add_read_record(id.clone());

        // 从存储中读取
        let storage = self.storage.lock()
            .map_err(|_| TransactionError::LockError("Storage lock failed".to_string()))?;
        let result = storage.get_node(id)
            .map_err(|e| TransactionError::StorageError(e.to_string()))?;
        Ok(result)
    }

    /// 在事务上下文中插入节点
    pub fn insert_node_in_tx(&self, tx_id: u64, vertex: Vertex) -> Result<Value, TransactionError> {
        let mut transactions = self.active_transactions.lock()
            .map_err(|_| TransactionError::LockError("Failed to acquire lock".to_string()))?;
        let context = transactions.get_mut(&tx_id)
            .ok_or(TransactionError::TransactionNotFound(tx_id))?;

        if !context.is_active() {
            return Err(TransactionError::InvalidState(tx_id));
        }

        // 记录修改前的状态（用于回滚）
        let old_value = {
            let storage = self.storage.lock()
                .map_err(|_| TransactionError::LockError("Storage lock failed".to_string()))?;
            storage.get_node(&vertex.vid)
                .map_err(|e| TransactionError::StorageError(e.to_string()))?
        };
        context.modified_data.insert((*vertex.vid).clone(), old_value);

        // 添加到写入集
        context.add_write_record((*vertex.vid).clone());

        // 将操作添加到事务操作列表
        context.add_operation(Operation::InsertNode(vertex.clone()))?;

        // 对于当前事务，直接返回生成的ID
        Ok((*vertex.vid).clone())
    }

    /// 在事务上下文中更新节点
    pub fn update_node_in_tx(&self, tx_id: u64, vertex: Vertex) -> Result<(), TransactionError> {
        let mut transactions = self.active_transactions.lock()
            .map_err(|_| TransactionError::LockError("Failed to acquire lock".to_string()))?;
        let context = transactions.get_mut(&tx_id)
            .ok_or(TransactionError::TransactionNotFound(tx_id))?;

        if !context.is_active() {
            return Err(TransactionError::InvalidState(tx_id));
        }

        // 记录修改前的状态（用于回滚）
        let old_value = {
            let storage = self.storage.lock()
                .map_err(|_| TransactionError::LockError("Storage lock failed".to_string()))?;
            storage.get_node(&vertex.vid)
                .map_err(|e| TransactionError::StorageError(e.to_string()))?
        };
        context.modified_data.insert((*vertex.vid).clone(), old_value);

        // 添加到写入集
        context.add_write_record((*vertex.vid).clone());

        // 将操作添加到事务操作列表
        context.add_operation(Operation::UpdateNode(vertex.clone()))?;

        Ok(())
    }

    /// 在事务上下文中删除节点
    pub fn delete_node_in_tx(&self, tx_id: u64, id: &Value) -> Result<(), TransactionError> {
        let mut transactions = self.active_transactions.lock()
            .map_err(|_| TransactionError::LockError("Failed to acquire lock".to_string()))?;
        let context = transactions.get_mut(&tx_id)
            .ok_or(TransactionError::TransactionNotFound(tx_id))?;

        if !context.is_active() {
            return Err(TransactionError::InvalidState(tx_id));
        }

        // 记录修改前的状态（用于回滚）
        let old_value = {
            let storage = self.storage.lock()
                .map_err(|_| TransactionError::LockError("Storage lock failed".to_string()))?;
            storage.get_node(id)
                .map_err(|e| TransactionError::StorageError(e.to_string()))?
        };
        context.modified_data.insert(id.clone(), old_value);

        // 添加到写入集
        context.add_write_record(id.clone());

        // 将操作添加到事务操作列表
        context.add_operation(Operation::DeleteNode(id.clone()))?;

        Ok(())
    }

    /// 提交事务
    pub fn commit_transaction(&self, tx_id: u64) -> Result<(), TransactionError> {
        let mut transactions = self.active_transactions.lock()
            .map_err(|_| TransactionError::LockError("Failed to acquire lock".to_string()))?;
        let mut context = transactions.get_mut(&tx_id)
            .ok_or(TransactionError::TransactionNotFound(tx_id))?;

        if !context.is_active() {
            return Err(TransactionError::InvalidState(tx_id));
        }

        // 获取操作列表的副本
        let operations = context.operations.clone();

        // 释放锁以便执行操作
        drop(transactions);

        // 应用所有操作到存储
        {
            let mut storage = self.storage.lock()
                .map_err(|_| TransactionError::LockError("Storage lock failed".to_string()))?;
            for op in operations {
                match op {
                    Operation::InsertNode(vertex) => {
                        storage.insert_node(vertex)
                            .map_err(|e| TransactionError::StorageError(e.to_string()))?;
                    }
                    Operation::UpdateNode(vertex) => {
                        storage.update_node(vertex)
                            .map_err(|e| TransactionError::StorageError(e.to_string()))?;
                    }
                    Operation::DeleteNode(id) => {
                        storage.delete_node(&id)
                            .map_err(|e| TransactionError::StorageError(e.to_string()))?;
                    }
                    // 其他操作类型...
                }
            }
        }

        // 更新事务状态
        {
            let mut transactions = self.active_transactions.lock()
                .map_err(|_| TransactionError::LockError("Failed to acquire lock".to_string()))?;
            if let Some(ctx) = transactions.get_mut(&tx_id) {
                ctx.state = TransactionState::Committed;
            }
        }

        Ok(())
    }

    /// 回滚事务
    pub fn rollback_transaction(&self, tx_id: u64) -> Result<(), TransactionError> {
        let mut transactions = self.active_transactions.lock()
            .map_err(|_| TransactionError::LockError("Failed to acquire lock".to_string()))?;
        let mut context = transactions.get_mut(&tx_id)
            .ok_or(TransactionError::TransactionNotFound(tx_id))?;

        if !context.is_active() {
            return Err(TransactionError::InvalidState(tx_id));
        }

        // 恢复所有修改前的状态
        {
            let mut storage = self.storage.lock()
                .map_err(|_| TransactionError::LockError("Storage lock failed".to_string()))?;
            
            for (id, old_value) in &context.modified_data {
                match old_value {
                    Some(vertex) => {
                        storage.update_node(vertex.clone())
                            .map_err(|e| TransactionError::StorageError(e.to_string()))?;
                    }
                    None => {
                        // 原来不存在，删除它
                        storage.delete_node(id)
                            .map_err(|e| TransactionError::StorageError(e.to_string()))?;
                    }
                }
            }
        }

        // 更新事务状态
        context.state = TransactionState::RolledBack;

        Ok(())
    }
}
```

### 4. 事务错误定义

#### 文件: `src/graph/transaction/error.rs`

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum TransactionError {
    #[error("Transaction {0} not found")]
    TransactionNotFound(u64),
    #[error("Transaction {0} is in invalid state")]
    InvalidState(u64),
    #[error("Storage error: {0}")]
    StorageError(String),
    #[error("Lock error: {0}")]
    LockError(String),
    #[error("Serialization error: {0}")]
    SerializationError(String),
    #[error("Transaction timeout")]
    Timeout,
    #[error("Deadlock detected")]
    Deadlock,
}
```

### 5. 主要模块文件

#### 文件: `src/graph/transaction/mod.rs`

```rust
pub mod isolation;
pub mod context;
pub mod manager;
pub mod error;

pub use isolation::IsolationLevel;
pub use context::{TransactionContext, TransactionState};
pub use manager::TransactionManager;
pub use error::TransactionError;

#[derive(Debug)]
pub enum Operation {
    InsertNode(crate::core::Vertex),
    UpdateNode(crate::core::Vertex),
    DeleteNode(crate::core::Value),
    InsertEdge(crate::core::Edge),
    DeleteEdge(crate::core::Value, crate::core::Value, String),
}
```

## 测试方案

### 集成测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::NativeStorage;
    use crate::core::{Vertex, Tag, Value};
    use std::sync::{Arc, Mutex};

    #[test]
    fn test_transaction_commit() {
        let temp_dir = tempfile::tempdir().unwrap();
        let storage = Arc::new(Mutex::new(NativeStorage::new(temp_dir.path()).unwrap()));
        let tx_manager = TransactionManager::new(storage.clone());

        // 开始事务
        let tx_id = tx_manager.begin_transaction(IsolationLevel::ReadCommitted).unwrap();

        // 在事务中插入节点
        let properties = [("name".to_string(), Value::String("Test".to_string()))]
            .iter().cloned().collect();
        let tag = Tag::new("Person".to_string(), properties);
        let vertex = Vertex::new(Value::Null(Default::default()), vec![tag]);
        let id = tx_manager.insert_node_in_tx(tx_id, vertex).unwrap();

        // 提交事务
        tx_manager.commit_transaction(tx_id).unwrap();

        // 验证数据已持久化
        let storage = storage.lock().unwrap();
        let retrieved = storage.get_node(&id).unwrap();
        assert!(retrieved.is_some());
    }

    #[test]
    fn test_transaction_rollback() {
        let temp_dir = tempfile::tempdir().unwrap();
        let storage = Arc::new(Mutex::new(NativeStorage::new(temp_dir.path()).unwrap()));
        let tx_manager = TransactionManager::new(storage.clone());

        // 预先插入一个节点
        let properties = [("name".to_string(), Value::String("Original".to_string()))]
            .iter().cloned().collect();
        let tag = Tag::new("Person".to_string(), properties);
        let vertex = Vertex::new(Value::Null(Default::default()), vec![tag]);
        let mut storage_lock = storage.lock().unwrap();
        let id = storage_lock.insert_node(vertex).unwrap();
        drop(storage_lock);

        // 开始事务
        let tx_id = tx_manager.begin_transaction(IsolationLevel::ReadCommitted).unwrap();

        // 在事务中更新节点
        let properties = [("name".to_string(), Value::String("Updated".to_string()))]
            .iter().cloned().collect();
        let tag = Tag::new("Person".to_string(), properties);
        let vertex = Vertex::new(id.clone(), vec![tag]);
        tx_manager.update_node_in_tx(tx_id, vertex).unwrap();

        // 回滚事务
        tx_manager.rollback_transaction(tx_id).unwrap();

        // 验证数据未更改
        let storage = storage.lock().unwrap();
        let retrieved = storage.get_node(&id).unwrap().unwrap();
        assert_eq!(retrieved.tags[0].properties.get("name"), Some(&Value::String("Original".to_string())));
    }
}
```

## 影响评估

1. 功能增强：支持完整的ACID事务特性
2. 性能：事务管理会增加额外开销，但提供数据一致性保证
3. 维护：事务系统变得更加完整和健壮
4. 兼容性：扩展是对现有功能的改进，保持向后兼容
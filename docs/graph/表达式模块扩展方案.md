# 表达式模块扩展方案

## 概述
当前的表达式模块实现了基本的二元、一元、函数、容器和聚合表达式，但缺少路径计算、高级函数等功能。本文档描述了扩展表达式模块的方案。

## 需求分析

### 缺失功能
1. 路径计算和图遍历相关的表达式
2. 高级数学函数
3. 字符串处理函数
4. 时间日期处理函数
5. 正则表达式支持

## 详细方案

### 1. 路径表达式模块

#### 文件: `src/graph/expression/path.rs`

```rust
use crate::core::{Path, Value, Vertex};
use crate::graph::expression::{EvalContext, Expression, ExprResult, ExprType};

pub struct PathExpression {
    /// 路径起点
    start: Box<dyn Expression>,
    /// 路径终点
    end: Option<Box<dyn Expression>>,
    /// 路径最大长度
    max_hops: Option<Box<dyn Expression>>,
    /// 路径类型条件
    edge_types: Vec<String>,
}

impl PathExpression {
    pub fn new(
        start: Box<dyn Expression>,
        end: Option<Box<dyn Expression>>,
        max_hops: Option<Box<dyn Expression>>,
        edge_types: Vec<String>,
    ) -> Self {
        Self {
            start,
            end,
            max_hops,
            edge_types,
        }
    }
}

impl Expression for PathExpression {
    fn eval(&self, context: &mut EvalContext) -> ExprResult {
        let start_val = self.start.eval(context)?;
        let start_id = match start_val {
            Value::Int(id) => id,
            _ => return Err(ExpressionError::TypeError("Start must be an ID".to_string())),
        };

        // 获取终点ID
        let end_id = if let Some(ref end_expr) = self.end {
            let end_val = end_expr.eval(context)?;
            match end_val {
                Value::Int(id) => Some(id),
                _ => return Err(ExpressionError::TypeError("End must be an ID".to_string())),
            }
        } else {
            None
        };

        // 获取最大跳数
        let max_hops = if let Some(ref hops_expr) = self.max_hops {
            let hops_val = hops_expr.eval(context)?;
            match hops_val {
                Value::Int(n) if n > 0 => n as usize,
                _ => return Err(ExpressionError::TypeError("Max hops must be a positive integer".to_string())),
            }
        } else {
            5 // 默认最大5跳
        };

        // 实现BFS查找路径
        let path = self.find_path(start_id, end_id, max_hops, context)?;
        Ok(Value::Path(path))
    }

    fn get_type(&self) -> ExprType {
        ExprType::Path
    }
}
```

### 2. 高级数学函数

#### 文件: `src/graph/expression/math.rs`

```rust
use crate::core::Value;
use crate::graph::expression::{EvalContext, Expression, ExprResult, ExprType};
use std::f64::consts::PI;

pub enum MathFunction {
    Abs,
    Ceil,
    Floor,
    Round,
    Sqrt,
    Exp,
    Log,
    Sin,
    Cos,
    Tan,
    Asin,
    Acos,
    Atan,
    Atan2,
    Pow,
    Min,
    Max,
}

pub struct MathExpression {
    function: MathFunction,
    args: Vec<Box<dyn Expression>>,
}

impl MathExpression {
    pub fn new(function: MathFunction, args: Vec<Box<dyn Expression>>) -> Self {
        Self { function, args }
    }

    fn eval_math(&self, args: &[Value]) -> Result<Value, ExpressionError> {
        match self.function {
            MathFunction::Abs => match &args[0] {
                Value::Int(n) => Ok(Value::Int(n.abs())),
                Value::Float(n) => Ok(Value::Float(n.abs())),
                _ => Err(ExpressionError::TypeError("Abs requires numeric value".to_string())),
            },
            MathFunction::Sqrt => match &args[0] {
                Value::Float(n) => Ok(Value::Float(n.sqrt())),
                Value::Int(n) => Ok(Value::Float((*n as f64).sqrt())),
                _ => Err(ExpressionError::TypeError("Sqrt requires numeric value".to_string())),
            },
            // 其他数学函数的实现...
            _ => Err(ExpressionError::FunctionError("Unsupported math function".to_string())),
        }
    }
}

impl Expression for MathExpression {
    fn eval(&self, context: &mut EvalContext) -> ExprResult {
        let mut eval_args = Vec::new();
        for arg in &self.args {
            eval_args.push(arg.eval(context)?);
        }
        self.eval_math(&eval_args)
    }

    fn get_type(&self) -> ExprType {
        ExprType::Function
    }
}
```

### 3. 字符串处理函数

#### 文件: `src/graph/expression/string.rs`

```rust
use crate::core::Value;
use crate::graph::expression::{EvalContext, Expression, ExprResult, ExprType};

pub enum StringFunction {
    Upper,
    Lower,
    Trim,
    Substring,
    Length,
    Replace,
    Concat,
    Split,
    Format,
}

pub struct StringExpression {
    function: StringFunction,
    args: Vec<Box<dyn Expression>>,
}

impl StringExpression {
    pub fn new(function: StringFunction, args: Vec<Box<dyn Expression>>) -> Self {
        Self { function, args }
    }

    fn eval_string(&self, args: &[Value]) -> Result<Value, ExpressionError> {
        match self.function {
            StringFunction::Upper => match &args[0] {
                Value::String(s) => Ok(Value::String(s.to_uppercase())),
                _ => Err(ExpressionError::TypeError("Upper requires string value".to_string())),
            },
            StringFunction::Length => match &args[0] {
                Value::String(s) => Ok(Value::Int(s.len() as i64)),
                _ => Err(ExpressionError::TypeError("Length requires string value".to_string())),
            },
            // 其他字符串函数的实现...
            _ => Err(ExpressionError::FunctionError("Unsupported string function".to_string())),
        }
    }
}

impl Expression for StringExpression {
    fn eval(&self, context: &mut EvalContext) -> ExprResult {
        let mut eval_args = Vec::new();
        for arg in &self.args {
            eval_args.push(arg.eval(context)?);
        }
        self.eval_string(&eval_args)
    }

    fn get_type(&self) -> ExprType {
        ExprType::Function
    }
}
```

### 4. 时间日期处理函数

#### 文件: `src/graph/expression/datetime.rs`

```rust
use crate::core::{Value, Date, Time, DateTime};
use crate::graph::expression::{EvalContext, Expression, ExprResult, ExprType};
use chrono::{NaiveDate, NaiveTime, NaiveDateTime};

pub enum DateTimeFunction {
    Year,
    Month,
    Day,
    Hour,
    Minute,
    Second,
    Now,
    DateAdd,
    DateDiff,
}

pub struct DateTimeExpression {
    function: DateTimeFunction,
    args: Vec<Box<dyn Expression>>,
}

impl DateTimeExpression {
    pub fn new(function: DateTimeFunction, args: Vec<Box<dyn Expression>>) -> Self {
        Self { function, args }
    }

    fn eval_datetime(&self, args: &[Value]) -> Result<Value, ExpressionError> {
        match self.function {
            DateTimeFunction::Now => {
                let now = chrono::Utc::now();
                Ok(Value::DateTime(DateTime {
                    year: now.year() as i32,
                    month: now.month() as u8,
                    day: now.day() as u8,
                    hour: now.hour() as u8,
                    minute: now.minute() as u8,
                    sec: now.second() as u8,
                    microsec: now.timestamp_subsec_micros(),
                }))
            }
            DateTimeFunction::Year => match &args[0] {
                Value::Date(d) => Ok(Value::Int(d.year as i64)),
                Value::DateTime(dt) => Ok(Value::Int(dt.year as i64)),
                _ => Err(ExpressionError::TypeError("Year requires date or datetime value".to_string())),
            },
            // 其他日期时间函数的实现...
            _ => Err(ExpressionError::FunctionError("Unsupported datetime function".to_string())),
        }
    }
}

impl Expression for DateTimeExpression {
    fn eval(&self, context: &mut EvalContext) -> ExprResult {
        let mut eval_args = Vec::new();
        for arg in &self.args {
            eval_args.push(arg.eval(context)?);
        }
        self.eval_datetime(&eval_args)
    }

    fn get_type(&self) -> ExprType {
        ExprType::Function
    }
}
```

### 5. 集成到现有的表达式模块

#### 文件: `src/graph/expression/mod.rs`

```rust
pub mod expr_type;
pub mod property;
pub mod binary;
pub mod unary;
pub mod function;
pub mod container;
pub mod aggregate;
pub mod context;
pub mod evaluator;
pub mod visitor;
pub mod error;
pub mod path;      // 新增路径表达式模块
pub mod math;      // 新增数学函数模块
pub mod string;    // 新增字符串函数模块
pub mod datetime;  // 新增日期时间函数模块
#[cfg(test)]
pub mod tests;

// Re-export公共类型
pub use expr_type::*;
pub use context::*;
pub use error::*;
pub use evaluator::*;
pub use binary::BinaryOperator;
pub use unary::UnaryOperator;
pub use path::PathExpression;      // 导出路径表达式
pub use math::{MathFunction, MathExpression};      // 导出数学函数
pub use string::{StringFunction, StringExpression}; // 导出字符串函数
pub use datetime::{DateTimeFunction, DateTimeExpression}; // 导出日期时间函数

// 类型别名，为了兼容性
pub type ExpressionContext<'a> = EvalContext<'a>;
```

## 测试方案

### 集成测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::graph::expression::{EvalContext, Value};

    #[test]
    fn test_path_expression() {
        // 测试路径表达式功能
    }

    #[test]
    fn test_math_expression() {
        // 测试数学函数功能
    }

    #[test]
    fn test_string_expression() {
        // 测试字符串函数功能
    }

    #[test]
    fn test_datetime_expression() {
        // 测试日期时间函数功能
    }
}
```

## 影响评估

1. 功能增强：表达式模块将支持更多类型的计算和查询操作
2. 性能：新增功能可能会对表达式求值性能产生轻微影响，需要进行基准测试
3. 维护：代码结构将更加清晰，功能模块化程度提高
4. 兼容性：新功能以模块化方式添加，不会影响现有功能
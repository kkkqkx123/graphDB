# GraphDB 查询语法分析文档

## 概述

GraphDB 是一个用 Rust 实现的图数据库项目，支持丰富的查询语法。本文档详细分析了该图数据库支持的所有查询语法类型、语法结构和功能特性。

## 查询语法分类

### 1. 数据查询语言 (DQL)

#### 1.1 MATCH - 模式匹配查询

**功能**: 使用图模式匹配查询节点和边

**语法结构**:
```cypher
MATCH <pattern> [WHERE <condition>] [RETURN <projection>] [ORDER BY <expression>] [LIMIT <n>] [SKIP <n>]
```

**关键特性**:
- 支持节点模式: `(variable:Label {prop: value})`
- 支持边模式: `-[variable:EdgeType {prop: value}]->`
- 支持路径模式: `(a)-[e]->(b)`
- 支持谓词过滤
- 支持属性投影
- 支持排序和分页

**示例**:
```cypher
MATCH (p:Person {name: 'Alice'})-[:FRIEND]->(f)
WHERE f.age > 25
RETURN p.name, f.name
ORDER BY f.age DESC
LIMIT 10
```

#### 1.2 GO - 图遍历查询

**功能**: 从起始节点开始进行图遍历

**语法结构**:
```cypher
GO <steps> FROM <vertex_id> OVER <edge_type> [REVERSELY] [BIDIRECT] [WHERE <condition>] [YIELD <properties>]
```

**关键特性**:
- 支持指定遍历步数
- 支持正向、反向、双向遍历
- 支持边类型过滤
- 支持条件过滤
- 支持属性投影

**示例**:
```cypher
GO 2 TO 4 STEPS FROM "123" OVER follow REVERSELY
WHERE target.age > 18
YIELD target.name, target.age
```

#### 1.3 LOOKUP - 基于索引查找

**功能**: 使用索引快速查找节点或边

**语法结构**:
```cypher
LOOKUP ON <tag_or_edge> WHERE <condition> [YIELD <properties>]
```

**关键特性**:
- 利用索引加速查询
- 支持标签和边类型
- 支持复合条件
- 支持属性投影

**示例**:
```cypher
LOOKUP ON person WHERE person.name == "Alice"
YIELD person.name, person.age
```

#### 1.4 FETCH - 获取数据

**功能**: 根据ID获取节点或边的详细信息

**语法结构**:
```cypher
FETCH PROP ON <tag> <vertex_id> [, <vertex_id> ...]
FETCH PROP ON <edge_type> <src_id> -> <dst_id> [@<rank>]
```

**关键特性**:
- 支持批量获取节点属性
- 支持获取边属性
- 支持指定边rank

**示例**:
```cypher
FETCH PROP ON person "101", "102", "103"
FETCH PROP ON follow "101" -> "102" @0
```

#### 1.5 FIND PATH - 路径查找

**功能**: 查找两个节点之间的路径，支持带权最短路径

**语法结构**:
```cypher
FIND <SHORTEST|ALL> PATH [WITH LOOP] [WITH CYCLE] FROM <src_id> TO <dst_id> OVER <edge_type> [REVERSELY] [BIDIRECT] [WHERE <condition>] [UPTO <steps> STEPS] [WEIGHT <weight_expr>]
```

**关键特性**:
- 支持最短路径查找
- 支持所有路径查找
- 支持带权最短路径（使用Dijkstra或A*算法）
- 路径顶点唯一性是默认行为（路径中不重复访问同一顶点）
- 支持显式允许自环边（A->A）
- 支持显式允许回路（路径中重复访问顶点）
- 支持路径长度限制
- 支持条件过滤

**环路控制选项**:

| 选项 | 默认 | 说明 |
|-----|------|------|
| `WITH CYCLE` | 无 | 允许路径中重复访问顶点（如 A->B->C->A） |
| `WITH LOOP` | 无 | 允许自环边（A->A），用于时序数据或List属性存储 |

**区别说明**:
- `WITH CYCLE`: 控制路径中是否允许重复访问顶点（如 A->B->C->A）
- `WITH LOOP`: 控制是否允许自环边（A->A），不影响路径顶点唯一性检测
- 两个选项独立工作，可以同时使用
- 默认情况下，路径顶点唯一且自环边被去重

**权重表达式**:
- `ranking`: 使用边的ranking字段作为权重
- `<property_name>`: 使用指定属性作为权重（如 `weight`, `distance`, `cost`）
- 省略WEIGHT子句: 使用无权图（BFS算法）

**算法选择**:
- **无权图**: 使用双向BFS算法，时间复杂度最优 O(b^(d/2))
- **带权图**: 使用Dijkstra算法，支持多对多最短路径
- **带权图+启发式**: 使用A*算法，适合单对单且有空间信息的场景

**示例**:
```cypher
-- 无权最短路径（默认去重自环边）
FIND SHORTEST PATH FROM "101" TO "201" OVER follow

-- 带权最短路径（使用weight属性）
FIND SHORTEST PATH FROM "101" TO "201" OVER follow WEIGHT weight

-- 带权最短路径（使用ranking字段）
FIND SHORTEST PATH FROM "101" TO "201" OVER follow WEIGHT ranking

-- 所有路径查询
FIND ALL PATH FROM "101" TO "201" OVER follow UPTO 5 STEPS

-- 带权所有路径查询
FIND ALL PATH FROM "101" TO "201" OVER follow WEIGHT distance UPTO 10 STEPS

-- 允许自环边（用于时序数据查询）
FIND ALL PATH WITH LOOP FROM "player100" TO "player200" OVER temp UPTO 5 STEPS

-- 允许回路（路径中可重复访问顶点）
FIND ALL PATH WITH CYCLE FROM "player100" TO "player200" OVER follow UPTO 5 STEPS

-- 同时允许自环边和回路
FIND ALL PATH WITH LOOP WITH CYCLE FROM "player100" TO "player200" OVER follow UPTO 5 STEPS
```

**注意**:
- 默认情况下，路径顶点唯一且自环边被去重
- 使用 `WITH LOOP` 可以允许自环边（A->A）
- 使用 `WITH CYCLE` 可以允许路径中重复访问顶点（如 A->B->C->A）
- 两个选项独立工作，可以同时使用
- 自环边可用于存储时序数据或List类型属性，参见[自环边使用场景](#自环边使用场景)

#### 1.6 SUBGRAPH - 子图查询

**功能**: 获取指定节点的子图结构

**语法结构**:
```cypher
GET SUBGRAPH WITH PROP <vertex_id> [, <vertex_id> ...] [IN <steps> STEPS] [OUT <steps> STEPS] [BOTH <steps> STEPS]
```

**关键特性**:
- 支持指定起始节点
- 支持入边、出边、双向扩展
- 支持扩展步数限制
- 包含属性信息

**示例**:
```cypher
GET SUBGRAPH WITH PROP "101", "102" IN 2 STEPS OUT 2 STEPS
```

### 2. 数据操作语言 (DML)

#### 2.1 INSERT - 插入数据

**功能**: 插入新的节点或边

**语法结构**:
```cypher
INSERT VERTEX <tag_name> (<prop_list>) VALUES <vid>: (<value_list>) [, <vid>: (<value_list>) ...]
INSERT EDGE <edge_type> (<prop_list>) VALUES <src_vid> -> <dst_vid> [@rank]: (<value_list>)
```

**关键特性**:
- 支持批量插入节点
- 支持插入边
- 支持指定边rank
- 支持多标签节点

**示例**:
```cypher
INSERT VERTEX person(name, age) VALUES "101": ("Alice", 25), "102": ("Bob", 30)
INSERT EDGE follow(degree) VALUES "101" -> "102" @0: (0.8)
```

#### 2.2 CREATE - 创建数据

**功能**: 创建节点和边（语法更灵活）

**语法结构**:
```cypher
CREATE (<variable>:<Label> {<prop>: <value>})
CREATE (<src>)-[:<EdgeType> {<prop>: <value>}]->(<dst>)
```

**关键特性**:
- Cypher风格语法
- 支持模式创建
- 支持变量绑定
- 支持属性设置

**示例**:
```cypher
CREATE (p:Person {name: 'Alice', age: 25})
CREATE (a:Person)-[:FRIEND {since: 2020}]->(b:Person)
```

#### 2.3 UPDATE - 更新数据

**功能**: 更新节点或边的属性

**语法结构**:
```cypher
UPDATE <vertex_id> SET <prop> = <value> [, <prop> = <value> ...] [WHEN <condition>]
UPDATE <src_vid> -> <dst_vid> [@<rank>] OF <edge_type> SET <prop> = <value> [, <prop> = <value> ...] [WHEN <condition>]
```

**关键特性**:
- 支持条件更新
- 支持多属性更新
- 支持节点和边更新
- 支持表达式计算

**示例**:
```cypher
UPDATE "101" SET age = 26, name = "Alice Smith" WHEN age > 20
UPDATE "101" -> "102" @0 OF follow SET degree = 0.9
```

#### 2.4 DELETE - 删除数据

**功能**: 删除节点或边

**语法结构**:
```cypher
DELETE VERTEX <vertex_id> [, <vertex_id> ...] [WITH EDGE]
DELETE EDGE <edge_type> <src_vid> -> <dst_vid> [@<rank>]
```

**关键特性**:
- 支持批量删除节点
- 支持删除边
- 支持指定边rank
- 支持级联删除关联边（WITH EDGE）
- 不指定WITH EDGE时保留边（产生悬挂边）

**示例**:
```cypher
-- 仅删除顶点，保留关联边（可能产生悬挂边）
DELETE VERTEX "101", "102"

-- 删除顶点及其所有关联边
DELETE VERTEX "101" WITH EDGE

-- 删除边
DELETE EDGE follow "101" -> "102" @0
```

**悬挂边说明**:
- 当删除顶点时不使用WITH EDGE，与该顶点关联的边会变成悬挂边（边的起点或终点不存在）
- 悬挂边可以通过GO语句查询到边属性，但点属性为空
- MATCH语句不会返回悬挂边
- 可以使用存储层API检测和修复悬挂边

#### 2.5 MERGE - 合并数据

**功能**: 如果存在则更新，不存在则创建

**语法结构**:
```cypher
MERGE (<variable>:<Label> {<prop>: <value>}) [ON MATCH SET <prop> = <value>] [ON CREATE SET <prop> = <value>]
```

**关键特性**:
- 幂等操作
- 支持存在时更新
- 支持不存在时创建
- 避免重复数据

**示例**:
```cypher
MERGE (p:Person {name: 'Alice'})
ON MATCH SET p.last_seen = timestamp()
ON CREATE SET p.created_at = timestamp()
```

#### 2.6 SET - 设置属性

**功能**: 设置或更新属性值

**语法结构**:
```cypher
SET <variable>.<prop> = <value> [, <variable>.<prop> = <value> ...]
```

**关键特性**:
- 支持动态属性设置
- 支持表达式计算
- 支持批量设置
- 与MATCH等语句配合使用

**示例**:
```cypher
MATCH (p:Person {name: 'Alice'})
SET p.age = 26, p.updated = true
```

#### 2.7 REMOVE - 移除属性

**功能**: 移除节点或边的属性

**语法结构**:
```cypher
REMOVE <variable>.<prop> [, <variable>.<prop> ...]
REMOVE <variable>:<Label> [, <variable>:<Label> ...]
```

**关键特性**:
- 支持移除属性
- 支持移除标签
- 支持批量操作

**示例**:
```cypher
MATCH (p:Person {name: 'Alice'})
REMOVE p.temp_field
REMOVE p:OldLabel
```

### 3. 数据定义语言 (DDL)

#### 3.1 CREATE TAG - 创建标签

**功能**: 定义节点标签及其属性

**语法结构**:
```cypher
CREATE TAG IF NOT EXISTS <tag_name> (<prop_name> <prop_type> [, <prop_name> <prop_type> ...])
```

**关键特性**:
- 支持多种数据类型
- 支持IF NOT EXISTS
- 支持TTL设置
- 支持默认值

**示例**:
```cypher
CREATE TAG IF NOT EXISTS person(name string, age int, created_at timestamp)
```

#### 3.2 CREATE EDGE - 创建边类型

**功能**: 定义边类型及其属性

**语法结构**:
```cypher
CREATE EDGE IF NOT EXISTS <edge_type> (<prop_name> <prop_type> [, <prop_name> <prop_type> ...])
```

**关键特性**:
- 支持多种数据类型
- 支持IF NOT EXISTS
- 支持TTL设置
- 支持默认值

**示例**:
```cypher
CREATE EDGE IF NOT EXISTS follow(degree float, since timestamp)
```

#### 3.3 ALTER TAG - 修改标签

**功能**: 修改标签定义

**语法结构**:
```cypher
ALTER TAG <tag_name> ADD (<prop_name> <prop_type> [, <prop_name> <prop_type> ...])
ALTER TAG <tag_name> DROP (<prop_name> [, <prop_name> ...])
ALTER TAG <tag_name> CHANGE (<old_prop> <new_prop> <prop_type>)
```

**关键特性**:
- 支持添加属性
- 支持删除属性
- 支持重命名属性
- 支持修改属性类型

**示例**:
```cypher
ALTER TAG person ADD (email string, phone string)
ALTER TAG person DROP (temp_field)
```

#### 3.4 ALTER EDGE - 修改边类型

**功能**: 修改边类型定义

**语法结构**:
```cypher
ALTER EDGE <edge_type> ADD (<prop_name> <prop_type> [, <prop_name> <prop_type> ...])
ALTER EDGE <edge_type> DROP (<prop_name> [, <prop_name> ...])
ALTER EDGE <edge_type> CHANGE (<old_prop> <new_prop> <prop_type>)
```

**关键特性**:
- 支持添加属性
- 支持删除属性
- 支持重命名属性
- 支持修改属性类型

**示例**:
```cypher
ALTER EDGE follow ADD (note string)
ALTER EDGE follow DROP (old_field)
```

#### 3.5 DROP TAG - 删除标签

**功能**: 删除标签定义

**语法结构**:
```cypher
DROP TAG IF EXISTS <tag_name> [, <tag_name> ...]
```

**关键特性**:
- 支持IF EXISTS
- 支持批量删除
- 级联删除相关数据

**示例**:
```cypher
DROP TAG IF EXISTS person, company
```

#### 3.6 DROP EDGE - 删除边类型

**功能**: 删除边类型定义

**语法结构**:
```cypher
DROP EDGE IF EXISTS <edge_type> [, <edge_type> ...]
```

**关键特性**:
- 支持IF EXISTS
- 支持批量删除
- 级联删除相关数据

**示例**:
```cypher
DROP EDGE IF EXISTS follow, like
```

#### 3.7 DESC - 描述对象

**功能**: 显示标签或边类型的定义

**语法结构**:
```cypher
DESCRIBE TAG <tag_name>
DESCRIBE EDGE <edge_type>
```

**关键特性**:
- 显示属性列表
- 显示属性类型
- 显示TTL设置
- 显示索引信息

**示例**:
```cypher
DESCRIBE TAG person
DESCRIBE EDGE follow
```

### 4. 数据控制语言 (DCL)

#### 4.1 CREATE USER - 创建用户

**功能**: 创建数据库用户

**语法结构**:
```cypher
CREATE USER IF NOT EXISTS <user_name> WITH PASSWORD '<password>'
```

**关键特性**:
- 支持IF NOT EXISTS
- 支持密码设置
- 支持权限分配

**示例**:
```cypher
CREATE USER IF NOT EXISTS alice WITH PASSWORD 'secure_password'
```

#### 4.2 ALTER USER - 修改用户

**功能**: 修改用户信息

**语法结构**:
```cypher
ALTER USER <user_name> WITH PASSWORD '<new_password>'
```

**关键特性**:
- 支持密码修改
- 支持权限修改

**示例**:
```cypher
ALTER USER alice WITH PASSWORD 'new_secure_password'
```

#### 4.3 DROP USER - 删除用户

**功能**: 删除用户

**语法结构**:
```cypher
DROP USER IF EXISTS <user_name>
```

**关键特性**:
- 支持IF EXISTS
- 清理用户权限

**示例**:
```cypher
DROP USER IF EXISTS alice
```

#### 4.4 CHANGE PASSWORD - 修改密码

**功能**: 修改当前用户密码

**语法结构**:
```cypher
CHANGE PASSWORD <old_password> TO <new_password>
```

**关键特性**:
- 需要验证旧密码
- 支持密码强度检查

**示例**:
```cypher
CHANGE PASSWORD 'old_pass' TO 'new_pass'
```

### 5. 管理和辅助语句

#### 5.1 USE - 使用图空间

**功能**: 切换当前图空间

**语法结构**:
```cypher
USE <graph_space_name>
```

**关键特性**:
- 切换工作空间
- 影响后续查询

**示例**:
```cypher
USE social_network
```

#### 5.2 SHOW - 显示信息

**功能**: 显示各种元数据信息

**语法结构**:
```cypher
SHOW SPACES
SHOW TAGS
SHOW EDGES
SHOW HOSTS
SHOW PARTS
```

**关键特性**:
- 显示图空间列表
- 显示标签列表
- 显示边类型列表
- 显示集群信息

**示例**:
```cypher
SHOW TAGS
SHOW SPACES
```

#### 5.3 EXPLAIN - 查询计划

**功能**: 显示查询执行计划

**语法结构**:
```cypher
EXPLAIN <query_statement>
```

**关键特性**:
- 显示执行计划
- 帮助性能优化
- 显示索引使用情况

**示例**:
```cypher
EXPLAIN MATCH (p:Person)-[:FRIEND]->(f) RETURN p.name, f.name
```

#### 5.4 RETURN - 返回结果

**功能**: 指定查询结果的返回格式

**语法结构**:
```cypher
RETURN <expression> [AS <alias>] [, <expression> [AS <alias>] ...]
```

**关键特性**:
- 支持表达式计算
- 支持别名
- 支持聚合函数
- 支持DISTINCT

**示例**:
```cypher
MATCH (p:Person)
RETURN p.name AS name, count(*) AS friend_count
```

#### 5.5 WITH - 中间结果处理

**功能**: 处理中间查询结果

**语法结构**:
```cypher
WITH <expression> [AS <alias>] [, <expression> [AS <alias>] ...]
```

**关键特性**:
- 链式查询
- 结果过滤
- 变量传递

**示例**:
```cypher
MATCH (p:Person)-[:FRIEND]->(f)
WITH p, count(f) AS friend_count
WHERE friend_count > 10
RETURN p.name, friend_count
```

#### 5.6 UNWIND - 展开列表

**功能**: 将列表展开为多行

**语法结构**:
```cypher
UNWIND <list_expression> AS <variable>
```

**关键特性**:
- 列表展开
- 支持嵌套展开
- 与其他语句配合使用

**示例**:
```cypher
UNWIND [1, 2, 3] AS n
RETURN n * 2
```

#### 5.7 PIPE - 管道操作

**功能**: 将查询结果传递给下一个查询

**语法结构**:
```cypher
<query_statement> | <query_statement>
```

**关键特性**:
- 链式操作
- 结果传递
- 复杂查询构建

**示例**:
```cypher
GO FROM "101" OVER follow YIELD follow._dst AS id | FETCH PROP ON person $-.id
```

## 数据类型

### 基本类型

1. **bool**: 布尔值 (true/false)
2. **int**: 整数
3. **int8/int16/int32/int64**: 不同位宽的整数
4. **float**: 浮点数
5. **double**: 双精度浮点数
6. **string**: 字符串
7. **timestamp**: 时间戳
8. **date**: 日期
9. **time**: 时间
10. **datetime**: 日期时间

### 复合类型

1. **list**: 列表 [1, 2, 3]
2. **map**: 映射 {key: value}
3. **set**: 集合 {1, 2, 3}

### 特殊类型

1. **vertex**: 节点ID
2. **edge**: 边信息
3. **path**: 路径

## 表达式

### 算术运算符

- `+`: 加法
- `-`: 减法
- `*`: 乘法
- `/`: 除法
- `%`: 取模
- `^`: 幂运算

### 比较运算符

- `==`: 等于
- `!=`: 不等于
- `>`: 大于
- `>=`: 大于等于
- `<`: 小于
- `<=`: 小于等于

### 逻辑运算符

- `AND`: 逻辑与
- `OR`: 逻辑或
- `NOT`: 逻辑非
- `XOR`: 逻辑异或

### 字符串运算符

- `+`: 字符串连接
- `STARTS WITH`: 前缀匹配
- `ENDS WITH`: 后缀匹配
- `CONTAINS`: 包含匹配
- `=~`: 正则表达式匹配

### 列表运算符

- `IN`: 元素包含
- `[index]`: 索引访问
- `[start:end]`: 切片

## 聚合函数

- `count()`: 计数
- `sum()`: 求和
- `avg()`: 平均值
- `min()`: 最小值
- `max()`: 最大值
- `stdev()`: 标准差
- `stdevp()`: 总体标准差
- `collect()`: 收集为列表

## 内置函数

### 字符串函数

- `upper()`: 转大写
- `lower()`: 转小写
- `trim()`: 去除空格
- `substring()`: 子串
- `replace()`: 替换
- `length()`: 长度

### 数学函数

- `abs()`: 绝对值
- `ceil()`: 向上取整
- `floor()`: 向下取整
- `round()`: 四舍五入
- `sqrt()`: 平方根
- `log()`: 对数
- `exp()`: 指数

### 时间函数

- `timestamp()`: 当前时间戳
- `date()`: 当前日期
- `now()`: 当前日期时间

### 类型转换函数

- `to_string()`: 转字符串
- `to_int()`: 转整数
- `to_float()`: 转浮点数
- `to_boolean()`: 转布尔值

## 索引

### 标签索引

```cypher
CREATE TAG INDEX IF NOT EXISTS index_name ON tag_name(prop_name)
```

### 边索引

```cypher
CREATE EDGE INDEX IF NOT EXISTS index_name ON edge_type(prop_name)
```

### 删除索引

```cypher
DROP TAG INDEX IF EXISTS index_name
DROP EDGE INDEX IF EXISTS index_name
```

### 查看索引

```cypher
SHOW TAG INDEXES
SHOW EDGE INDEXES
```

## 查询优化

### 使用索引

```cypher
LOOKUP ON person WHERE person.name == "Alice"
```

### 限制返回结果

```cypher
MATCH (p:Person) RETURN p LIMIT 100
```

### 使用EXPLAIN分析

```cypher
EXPLAIN MATCH (p:Person)-[:FRIEND]->(f) RETURN p, f
```

### 避免全表扫描

```cypher
# 不推荐
MATCH (p:Person) WHERE p.age > 25 RETURN p

# 推荐
LOOKUP ON person WHERE person.age > 25 YIELD person AS p
```

## 事务支持

虽然当前版本主要关注单节点部署，但支持基本的事务操作：

```cypher
BEGIN TRANSACTION
-- 多个操作
COMMIT

-- 或回滚
ROLLBACK
```

## 带权图查询详解

### 概述

GraphDB 支持带权图的最短路径查询，使用 Dijkstra 或 A* 算法计算最优路径。权重可以基于边的属性或 ranking 字段。

### 权重配置

#### 1. 使用边属性作为权重

```cypher
-- 使用 weight 属性作为权重
FIND SHORTEST PATH FROM "A" TO "C" OVER connect WEIGHT weight

-- 使用 distance 属性作为权重
FIND SHORTEST PATH FROM "A" TO "C" OVER road WEIGHT distance

-- 使用 cost 属性作为权重
FIND SHORTEST PATH FROM "A" TO "C" OVER route WEIGHT cost
```

#### 2. 使用 ranking 作为权重

```cypher
-- 使用边的 ranking 字段作为权重
FIND SHORTEST PATH FROM "A" TO "C" OVER connect WEIGHT ranking
```

#### 3. 无权图（默认）

```cypher
-- 不指定 WEIGHT，使用步数作为距离
FIND SHORTEST PATH FROM "A" TO "C" OVER connect
```

### 算法选择

系统根据查询特征自动选择最优算法：

| 场景 | 算法 | 时间复杂度 | 适用场景 |
|------|------|-----------|----------|
| 无权图，单对单 | 双向 BFS | O(b^(d/2)) | 无权最短路径，最快 |
| 无权图，多对多 | BFS | O(V+E) | 无权多源最短路径 |
| 带权图，多对多 | Dijkstra | O((V+E)logV) | 带权最短路径，通用 |
| 带权图，单对单，有启发式 | A* | O(E) | 带权最短路径，有空间信息时最优 |

### 启发式函数（A*算法）

A* 算法支持以下启发式函数：

#### 1. 零启发式（退化为 Dijkstra）

```rust
HeuristicFunction::Zero
```

#### 2. 基于属性的空间距离

```rust
HeuristicFunction::PropertyDistance("lat".to_string(), "lon".to_string())
```

适用于有坐标属性的图，如地图导航。

#### 3. 固定缩放因子

```rust
HeuristicFunction::ScaleFactor(0.5)
```

### 性能优化建议

1. **选择合适的算法**（自动优化，无需用户干预）
   - 无权图使用 BFS，避免不必要的计算
   - 带权图使用 Dijkstra 或 A*
   - 有空间信息时使用 A* 加速

2. **限制搜索深度**
   ```cypher
   FIND SHORTEST PATH FROM "A" TO "C" OVER connect WEIGHT weight UPTO 10 STEPS
   ```

3. **使用索引**
   - 为权重属性创建索引，加速边过滤
   - 为起点和终点创建索引，加速顶点查找

4. **批量查询**
   - 使用多源最短路径查询替代多次单源查询

### 注意事项

1. **权重值类型**
   - 支持整数和浮点数权重
   - 权重值必须为非负数（Dijkstra算法要求）
   - 负权重边会导致算法失效

2. **路径存在性**
   - 如果起点和终点不连通，返回空结果
   - 使用 `UPTO` 限制搜索深度，避免无限搜索

3. **内存使用**
   - 大规模图查询可能消耗大量内存
   - 建议分批处理或限制搜索深度

### 自环边使用场景

自环边（起点和终点相同的边，即 A->A）在图数据库中有特殊的应用场景。通过 `WITH LOOP` 语法可以控制是否允许自环边参与路径查询。

#### 自环边 vs 回路

| 特性 | `WITH CYCLE` | `WITH LOOP` |
|-----|--------------|-------------|
| 控制对象 | 路径中的顶点重复 | 自环边（A->A） |
| 默认行为 | 不允许（路径顶点唯一） | 不允许（自环边去重） |
| 典型场景 | 允许循环路径 | 时序数据、List属性 |
| 相互影响 | 独立工作 | 独立工作 |

**示例说明**:
```cypher
-- 场景1：默认（无 WITH CYCLE，无 WITH LOOP）
-- 路径 A->B->C->A 会被过滤（顶点A重复）
-- 自环边 A->A 会被去重

-- 场景2：WITH LOOP
-- 路径 A->B->C->A 会被过滤（顶点A重复）
-- 自环边 A->A 会被保留

-- 场景3：WITH CYCLE WITH LOOP
-- 路径 A->B->C->A 会被保留（允许顶点重复）
-- 自环边 A->A 会被保留
```

#### 1. 存储时序数据

当需要为顶点存储带时间戳的属性变化时，可以使用自环边：

```cypher
-- 创建带时间属性的边类型
CREATE EDGE temp(tmp string)

-- 插入带时间戳的自环边（使用ranking存储时间戳）
INSERT EDGE temp(tmp) VALUES "player100" -> "player100" @1: ("2024-01-01")
INSERT EDGE temp(tmp) VALUES "player100" -> "player100" @2: ("2024-02-01")
INSERT EDGE temp(tmp) VALUES "player100" -> "player100" @3: ("2024-03-01")

-- 查询时序数据（使用 WITH LOOP 保留自环边）
FIND ALL PATH WITH LOOP FROM "player100" TO "player100" OVER temp YIELD properties(edge).tmp, rank(edge)
```

**为什么使用自环边而不是顶点属性？**
- 顶点属性会被新写入的值覆盖，无法保留历史记录
- 自环边使用ranking字段可以存储时间戳，支持多版本数据
- 通过 `WITH LOOP` 可以在查询时保留这些历史记录

#### 2. 存储List类型属性

GraphDB不支持直接将List类型作为顶点或边的属性，但可以通过自环边模拟：

```cypher
-- 创建边类型存储List元素
CREATE EDGE list_item(value string)

-- 为顶点添加多个List元素（使用自环边）
INSERT EDGE list_item(value) VALUES "user1" -> "user1" @1: ("item1")
INSERT EDGE list_item(value) VALUES "user1" -> "user1" @2: ("item2")
INSERT EDGE list_item(value) VALUES "user1" -> "user1" @3: ("item3")

-- 查询所有List元素（必须启用 allow_self_loop）
FIND ALL PATH ALLOW SELF LOOP FROM "user1" TO "user1" OVER list_item YIELD properties(edge).value
```

#### 3. 替代悬挂边

之前一些用户使用悬挂边（dangling edge，指向不存在顶点的边）来存储时序或List数据，但这可能导致数据不一致问题。建议使用自环边替代悬挂边：

- **数据一致性**：自环边指向自身，不会出现悬挂问题
- **查询效率**：自环边可以正常参与图遍历，不需要特殊处理
- **语义清晰**：自环边明确表示数据属于该顶点

#### 4. 实现细节

在代码中使用 `allow_self_loop`：

```rust
// 创建算法上下文，启用自环边
let context = AlgorithmContext::new()
    .with_path_unique_vertices(true)  // 路径顶点唯一
    .with_allow_self_loop(true);       // 允许自环边

// 创建执行器
let executor = ExpandExecutor::new(...)
    .with_allow_self_loop(true);
```

**注意事项**：
- 自环边在遍历时可能导致无限循环，建议配合 `max_depth` 使用
- 大量自环边会增加存储和查询开销
- 时序数据建议结合 `ranking` 字段使用，确保数据有序

## 悬挂边处理

### 概述

悬挂边（Dangling Edge）是指起点或终点顶点不存在的边。GraphDB允许悬挂边的存在，这与NebulaGraph的设计保持一致。

### 悬挂边的产生场景

1. **插入边时顶点不存在**
   ```cypher
   -- 插入边时，起点或终点顶点可以不存在
   INSERT EDGE follow(degree) VALUES "101" -> "999" @0: (0.8)
   -- 如果顶点"999"不存在，则产生悬挂边
   ```

2. **删除顶点时不删除关联边**
   ```cypher
   -- 仅删除顶点，保留关联边
   DELETE VERTEX "101"
   -- 与顶点"101"关联的边变成悬挂边
   ```

### 悬挂边的查询行为

#### GO语句
GO语句支持返回悬挂边的属性，但点属性为空：
```cypher
-- 假设顶点"999"不存在，但边"101"->"999"存在
GO FROM "101" OVER follow YIELD target.name, edge.degree
-- 结果：target.name为NULL，edge.degree返回边的实际属性值
```

#### MATCH语句
MATCH语句不会返回悬挂边：
```cypher
-- 如果边的终点不存在，该边不会出现在结果中
MATCH (n:Person)-[e:follow]->(m:Person) RETURN n, e, m
```

### 悬挂边管理工具

GraphDB提供存储层API用于检测和修复悬挂边：

#### 检测悬挂边
```rust
// 查找指定空间中的所有悬挂边
let dangling_edges = storage.find_dangling_edges("space_name")?;
println!("发现 {} 条悬挂边", dangling_edges.len());
```

#### 修复悬挂边
```rust
// 删除所有悬挂边，返回删除的数量
let repaired_count = storage.repair_dangling_edges("space_name")?;
println!("修复了 {} 条悬挂边", repaired_count);
```

#### 删除顶点时级联删除边
```rust
// 删除顶点及其所有关联边
storage.delete_vertex_with_edges("space_name", &vertex_id)?;
```

### 最佳实践

1. **避免悬挂边**
   - 删除顶点时使用 `WITH EDGE` 语法级联删除关联边
   - 在应用层确保插入边时顶点已存在

2. **定期检测和修复**
   - 使用 `find_dangling_edges` 定期检测悬挂边
   - 使用 `repair_dangling_edges` 清理悬挂边

3. **利用悬挂边特性**
   - 在某些场景下，悬挂边可用于特殊的数据建模需求
   - GO语句可以查询悬挂边的属性

## 总结

GraphDB 提供了完整的图数据库查询语言支持，包括：

1. **丰富的查询语法**: 支持模式匹配、图遍历、路径查找等多种查询方式
2. **完整的数据操作**: 支持增删改查等完整的数据操作
3. **灵活的数据定义**: 支持标签和边类型的创建和修改
4. **强大的表达式**: 支持各种运算符和内置函数
5. **索引支持**: 提供索引功能提升查询性能
6. **用户管理**: 支持用户和权限管理
7. **带权图查询**: 支持带权最短路径查询，使用 Dijkstra 和 A* 算法

该查询语言设计参考了 Cypher 和 nGQL 的优点，提供了直观且强大的图数据库操作能力。

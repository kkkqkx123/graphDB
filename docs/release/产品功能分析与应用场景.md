# GraphDB 产品功能分析与应用场景

## 1. 项目概述

GraphDB 是一个基于 Rust 语言重新实现的**单节点图数据库**，旨在为个人和小规模应用提供轻量级、高性能的图数据存储与查询解决方案。该项目从 NebulaGraph 中汲取设计理念，但移除了分布式功能，显著减少了外部依赖，专注于本地单节点部署场景。

### 1.1 核心定位

- **轻量级**: 单可执行文件部署，无复杂依赖
- **高性能**: 利用 Rust 的内存安全和零成本抽象
- **易用性**: 简化配置，开箱即用
- **兼容性**: 参考 NebulaGraph 的查询语法设计

### 1.2 技术栈

| 组件 | 技术选择 | 说明 |
|------|----------|------|
| 编程语言 | Rust 1.88+ | 内存安全、高性能 |
| 存储引擎 | RedB / RocksDB | 嵌入式键值存储 |
| 异步运行时 | Tokio | 高并发处理 |
| 序列化 | Bincode / Serde | 高效数据编码 |
| 日志系统 | Flexi Logger | 异步日志记录 |

---

## 2. 主要功能模块

### 2.1 数据模型

GraphDB 采用**属性图模型**，核心概念包括：

#### 2.1.1 图空间（Space）
- 逻辑数据隔离单元，类似数据库概念
- 支持多 Space 管理（创建、删除、切换）
- 每个 Space 拥有独立的 Schema 和数据

#### 2.1.2 节点（Vertex）
- 图中的实体，具有唯一标识符
- 可附加多个标签（Tag）
- 每个标签可定义多个属性

#### 2.1.3 边（Edge）
- 连接两个节点的关系
- 有向边，支持单向、双向遍历
- 可附加属性和排序权重（Rank）

#### 2.1.4 标签（Tag）
- 节点的类型定义
- 定义属性结构和数据类型

#### 2.1.5 边类型（Edge Type）
- 边的类型定义
- 定义边的属性结构

### 2.2 支持的值类型

| 类型类别 | 具体类型 | 说明 |
|----------|----------|------|
| 基础类型 | Null, Bool, Int, Float, String | 基本数据类型 |
| 日期时间 | Date, Time, DateTime, Duration | 时间相关类型 |
| 地理空间 | Geography, Point, LineString, Polygon | GIS 数据支持 |
| 复合类型 | List, Map, Set | 集合类型 |
| 图类型 | Vertex, Edge, Path | 图核心类型 |
| 数据集 | DataSet | 查询结果集 |

### 2.3 查询语言（nGQL 子集）

#### 2.3.1 数据查询语言（DQL）

| 语句 | 功能描述 | 示例 |
|------|----------|------|
| **MATCH** | 模式匹配查询 | `MATCH (p:Person)-[:FRIEND]->(f) RETURN p.name, f.name` |
| **GO** | 图遍历查询 | `GO 2 STEPS FROM "123" OVER follow YIELD dst(edge)` |
| **LOOKUP** | 索引查找 | `LOOKUP ON person WHERE person.name == "Alice"` |
| **FETCH** | 属性获取 | `FETCH PROP ON person "101", "102"` |
| **FIND PATH** | 路径查找 | `FIND SHORTEST PATH FROM "101" TO "201" OVER follow` |
| **SUBGRAPH** | 子图查询 | `GET SUBGRAPH WITH PROP "101" IN 2 STEPS` |

#### 2.3.2 数据定义语言（DDL）

| 语句 | 功能描述 |
|------|----------|
| **CREATE SPACE** | 创建图空间 |
| **USE** | 切换图空间 |
| **CREATE TAG** | 创建节点标签 |
| **CREATE EDGE** | 创建边类型 |
| **CREATE INDEX** | 创建索引 |
| **DROP/DESC/ALTER** | 删除、描述、修改 |
| **SHOW** | 查看元数据 |

#### 2.3.3 数据操作语言（DML）

| 语句 | 功能描述 |
|------|----------|
| **INSERT VERTEX** | 插入节点 |
| **INSERT EDGE** | 插入边 |
| **UPDATE** | 更新数据 |
| **DELETE** | 删除数据 |
| **UPSERT** | 插入或更新 |

#### 2.3.4 数据控制语言（DCL）

| 语句 | 功能描述 |
|------|----------|
| **CREATE USER** | 创建用户 |
| **GRANT/REVOKE** | 授权/回收权限 |
| **CHANGE PASSWORD** | 修改密码 |
| **DROP USER** | 删除用户 |

### 2.4 查询执行引擎

#### 2.4.1 执行流程

```
查询字符串 → 词法分析 → 语法分析 → AST
    ↓
语义验证 → 查询计划生成 → 计划优化
    ↓
计划执行 → 结果返回
```

#### 2.4.2 核心组件

| 组件 | 功能 |
|------|------|
| **Parser** | 查询解析，生成 AST |
| **Validator** | 语义验证，类型检查 |
| **Planner** | 生成执行计划 |
| **Optimizer** | 计划优化（规则优化、代价优化）|
| **Executor** | 计划执行 |

#### 2.4.3 支持的执行算子

- **数据访问**: GetNeighbors, GetVertices, GetEdges, IndexScan
- **数据处理**: Filter, Project, Aggregation, Sort, Limit, Dedup
- **图遍历**: Traverse, ShortestPath, AllPaths
- **集合操作**: Union, Intersect, Minus
- **连接操作**: InnerJoin, LeftJoin, RightJoin, FullOuterJoin, CrossJoin

### 2.5 存储引擎

#### 2.5.1 存储架构

- **存储后端**: 基于 RedB（默认）或 RocksDB
- **数据编码**: Bincode 序列化
- **索引支持**: 标签索引、边类型索引
- **元数据管理**: Space、Tag、EdgeType、Index 等元数据

#### 2.5.2 存储接口

```rust
pub trait StorageClient: Send + Sync {
    // 节点操作
    fn get_vertex(&self, space: &str, id: &Value) -> Result<Option<Vertex>, StorageError>;
    fn insert_vertex(&mut self, space: &str, vertex: Vertex) -> Result<Value, StorageError>;
    fn delete_vertex(&mut self, space: &str, id: &Value) -> Result<(), StorageError>;
    
    // 边操作
    fn get_edge(&self, space: &str, src: &Value, dst: &Value, edge_type: &str) -> Result<Option<Edge>, StorageError>;
    fn insert_edge(&mut self, space: &str, edge: Edge) -> Result<(), StorageError>;
    fn delete_edge(&mut self, space: &str, src: &Value, dst: &Value, edge_type: &str) -> Result<(), StorageError>;
    
    // 元数据操作
    fn create_space(&mut self, space: &SpaceInfo) -> Result<bool, StorageError>;
    fn create_tag(&mut self, space: &str, tag: &TagInfo) -> Result<bool, StorageError>;
    fn create_edge_type(&mut self, space: &str, edge: &EdgeTypeInfo) -> Result<bool, StorageError>;
    
    // 索引操作
    fn create_tag_index(&mut self, space: &str, info: &Index) -> Result<bool, StorageError>;
    fn create_edge_index(&mut self, space: &str, info: &Index) -> Result<bool, StorageError>;
}
```

### 2.6 安全与权限

#### 2.6.1 认证机制
- 基于用户名/密码的认证
- bcrypt 密码加密
- 支持配置默认用户

#### 2.6.2 角色权限

| 角色 | 权限范围 |
|------|----------|
| **God** | 全局超级管理员，拥有所有权限 |
| **Admin** | Space 管理员，管理特定 Space |
| **User** | 普通用户，受限的数据访问权限 |
| **Guest** | 访客，只读权限 |

#### 2.6.3 会话管理
- 会话创建和销毁
- 空闲超时检测
- 最大连接数限制
- 查询执行统计

### 2.7 表达式系统

#### 2.7.1 支持的表达式类型

- **常量表达式**: 字面量值
- **列引用**: 属性访问
- **算术表达式**: +, -, *, /, %
- **比较表达式**: =, !=, <, >, <=, >=
- **逻辑表达式**: AND, OR, NOT
- **函数调用**: 内置函数、聚合函数
- **条件表达式**: CASE WHEN

#### 2.7.2 内置函数

- **数学函数**: abs, ceil, floor, round, sqrt, pow
- **字符串函数**: concat, substring, length, upper, lower
- **日期函数**: now, date, datetime, duration
- **聚合函数**: count, sum, avg, max, min, collect
- **图函数**: id, tags, properties, src, dst, type, rank

---

## 3. 主要应用场景

### 3.1 社交网络分析

#### 场景描述
构建用户关系网络，分析社交行为和影响力。

#### 数据模型
```
顶点: Person(id, name, age, city, created_at)
      Post(id, content, created_at, likes)
      Group(id, name, description)

边:   KNOWS(since, strength)
      FOLLOWS(since)
      POSTED
      LIKES(created_at)
      MEMBER_OF(joined_at, role)
```

#### 典型查询
```sql
-- 查找共同好友
MATCH (a:Person)-[:KNOWS]->(common)<-[:KNOWS]-(b:Person)
WHERE a.name == 'Alice' AND b.name == 'Bob'
RETURN common.name

-- 好友推荐（基于共同好友数量）
MATCH (me:Person)-[:KNOWS]->(friend)-[:KNOWS]->(potential)
WHERE me.name == 'Alice' AND NOT (me)-[:KNOWS]->(potential)
RETURN potential.name, count(*) as common_friends
ORDER BY common_friends DESC LIMIT 10

-- 影响力分析（多层传播）
GO 3 STEPS FROM "Alice" OVER FOLLOWS
YIELD dst(edge) as follower, $^.Person.name as name
```

#### 应用价值
- 好友推荐系统
- 社区发现与分群
- 影响力传播分析
- 信息扩散路径追踪

### 3.2 知识图谱

#### 场景描述
构建实体关系网络，支持知识推理和查询。

#### 数据模型
```
顶点: Entity(id, name, type, description)
      Concept(id, name, domain)
      Document(id, title, content, source)

边:   RELATES_TO(relation_type, confidence)
      INSTANCE_OF
      MENTIONS(frequency)
      PART_OF
      CAUSES
```

#### 典型查询
```sql
-- 实体关系查询
MATCH (e:Entity)-[r:RELATES_TO]->(related:Entity)
WHERE e.name == '人工智能'
RETURN r.relation_type, related.name

-- 多跳关系推理
MATCH path = (start:Entity)-[:RELATES_TO*1..3]->(end:Entity)
WHERE start.name == '机器学习'
RETURN path LIMIT 10

-- 知识补全候选生成
MATCH (a:Entity)-[r1]->(b:Entity), (a)-[r2]->(c:Entity)
WHERE b != c AND NOT (b)-[]->(c)
RETURN a.name, b.name, c.name as potential_relation
```

#### 应用价值
- 智能问答系统
- 知识推理与补全
- 语义搜索
- 文档知识抽取

### 3.3 电商推荐系统

#### 场景描述
基于用户行为和商品关系构建推荐引擎。

#### 数据模型
```
顶点: User(id, name, age, gender, city)
      Product(id, name, category, price, brand)
      Category(id, name, parent_id)
      Order(id, total_amount, status, created_at)

边:   VIEWED(view_time, duration)
      ADDED_TO_CART(added_at, quantity)
      PURCHASED(order_id, quantity, price)
      BELONGS_TO
      SIMILAR_TO(similarity_score)
      BOUGHT_TOGETHER(frequency)
```

#### 典型查询
```sql
-- 协同过滤推荐
MATCH (u:User)-[:PURCHASED]->(product)<-[:PURCHASED]-(similar:User)
WHERE u.id == 123
MATCH (similar)-[:PURCHASED]->(recommendation)
WHERE NOT (u)-[:PURCHASED]->(recommendation)
RETURN recommendation.name, count(*) as score
ORDER BY score DESC LIMIT 10

-- 购买路径分析
MATCH path = (u:User)-[:VIEWED]->(:Product)-[:ADDED_TO_CART]->(:Product)-[:PURCHASED]->(:Product)
WHERE u.id == 123
RETURN path

-- 热销商品排行
MATCH (:User)-[p:PURCHASED]->(product:Product)
RETURN product.name, sum(p.quantity) as total_sales
ORDER BY total_sales DESC LIMIT 20
```

#### 应用价值
- 个性化商品推荐
- 购物车放弃分析
- 用户行为路径分析
- 热销趋势预测

### 3.4 网络安全分析

#### 场景描述
分析网络拓扑和流量，检测异常行为。

#### 数据模型
```
顶点: Device(id, ip, type, os, location)
      User(id, name, department, role)
      Domain(id, name, category, risk_score)

边:   CONNECTS(port, protocol, timestamp)
      ACCESSED(timestamp, duration)
      RESOLVES(timestamp)
      BELONGS_TO
```

#### 典型查询
```sql
-- 异常连接检测
MATCH (d:Device)-[c:CONNECTS]->(target:Device)
WHERE c.timestamp > now() - 3600
WITH d, count(*) as connection_count
WHERE connection_count > 1000
RETURN d.ip, connection_count

-- 横向移动检测
MATCH path = (start:Device)-[:CONNECTS*2..5]->(end:Device)
WHERE start.risk_score > 0.8
RETURN path

-- 域名解析异常
MATCH (d:Device)-[r:RESOLVES]->(domain:Domain)
WHERE domain.risk_score > 0.9 AND r.timestamp > now() - 86400
RETURN d.ip, domain.name, count(*) as query_count
```

#### 应用价值
- 异常行为检测
- 攻击路径追踪
- 威胁情报关联
- 安全事件响应

### 3.5 金融风控

#### 场景描述
构建客户关系网络，识别欺诈模式和风险传导。

#### 数据模型
```
顶点: Account(id, type, balance, risk_level, created_at)
      Customer(id, name, id_number, phone, address)
      Company(id, name, industry, registered_capital)

边:   TRANSFER(amount, timestamp, purpose)
      OWNS(percentage)
      GUARANTEES(amount, timestamp)
      FAMILY_RELATION(relation_type)
```

#### 典型查询
```sql
-- 关联交易识别
MATCH (c1:Customer)-[:OWNS]->(:Account)-[t:TRANSFER]->(:Account)<-[:OWNS]-(c2:Customer)
WHERE t.amount > 1000000 AND t.timestamp > now() - 2592000
RETURN c1.name, c2.name, sum(t.amount) as total_transfer

-- 担保圈检测
MATCH path = (c1:Company)-[:GUARANTEES*3..10]->(c1)
RETURN path

-- 风险传导分析
MATCH (start:Account)-[:TRANSFER*1..5]->(target:Account)
WHERE start.risk_level == 'high'
RETURN target.id, min(length(path)) as distance
ORDER BY distance
```

#### 应用价值
- 欺诈团伙识别
- 信用风险评估
- 担保圈监测
- 资金流向追踪

### 3.6 IT 运维管理

#### 场景描述
管理 IT 资产和依赖关系，支持故障分析和变更管理。

#### 数据模型
```
顶点: Server(id, hostname, ip, os, cpu, memory, status)
      Application(id, name, version, owner, criticality)
      Database(id, name, type, size, backup_status)
      Service(id, name, type, port, health)

边:   DEPENDS_ON(dependency_type)
      HOSTS_ON
      CONNECTS_TO(protocol, port)
      CALLS(api_endpoint, call_frequency)
```

#### 典型查询
```sql
-- 故障影响分析
MATCH (failed:Server)-[:HOSTS_ON*0..]->(app:Application)
WHERE failed.status == 'down'
RETURN app.name, app.criticality

-- 变更影响评估
MATCH path = (target:Service)-[:DEPENDS_ON|CALLS*1..5]->(dependent:Service)
WHERE target.id == 'service_001'
RETURN dependent.name, length(path) as impact_level

-- 资源利用率分析
MATCH (app:Application)-[:HOSTS_ON]->(server:Server)
RETURN server.hostname, count(app) as app_count, 
       avg(app.memory_usage) as avg_memory
ORDER BY avg_memory DESC
```

#### 应用价值
- 故障根因分析
- 变更影响评估
- 资源优化建议
- 依赖关系可视化

---

## 4. 部署与使用方式

### 4.1 部署模式

#### 4.1.1 单机部署

```bash
# 启动服务
cargo run --release -- serve --config config.toml

# 或使用默认配置
cargo run --release -- serve
```

#### 4.1.2 配置示例

```toml
[database]
host = "127.0.0.1"
port = 9758
storage_path = "data/graphdb"
max_connections = 10
transaction_timeout = 30

[log]
level = "info"
dir = "logs"
file = "graphdb"
max_file_size = 104857600
max_files = 5

[auth]
enable_authorize = true
default_username = "root"
default_password = "root"
session_idle_timeout_secs = 3600
```

### 4.2 交互方式

#### 4.2.1 命令行查询

```bash
# 直接执行查询
cargo run --release -- query --query "MATCH (n) RETURN n LIMIT 10"
```

#### 4.2.2 编程 API（待实现）

```rust
// Rust API 示例（规划中）
use graphdb::client::GraphClient;

#[tokio::main]
async fn main() -> Result<()> {
    let client = GraphClient::connect("127.0.0.1:9758").await?;
    
    // 认证
    let session = client.authenticate("root", "root").await?;
    
    // 执行查询
    let result = session.execute("MATCH (p:Person) RETURN p.name").await?;
    println!("{:?}", result);
    
    Ok(())
}
```

---

## 5. 功能完整度评估

### 5.1 已实现功能

| 模块 | 功能 | 状态 |
|------|------|------|
| 存储引擎 | 基础 CRUD | ✅ 完成 |
| 存储引擎 | 元数据管理 | ✅ 完成 |
| 存储引擎 | 索引管理 | ✅ 完成 |
| 查询解析 | 词法/语法分析 | ✅ 完成 |
| 查询解析 | AST 生成 | ✅ 完成 |
| 查询计划 | 计划生成 | ✅ 完成 |
| 查询计划 | 计划缓存 | ✅ 完成 |
| 查询优化 | 规则优化 | ✅ 完成 |
| 查询优化 | 代价优化 | ⚠️ 部分 |
| 查询执行 | 基础算子 | ✅ 完成 |
| 查询执行 | 图遍历 | ✅ 完成 |
| 查询执行 | 路径查找 | ✅ 完成 |
| 查询执行 | 连接操作 | ✅ 完成 |
| 权限管理 | 用户认证 | ✅ 完成 |
| 权限管理 | 角色权限 | ✅ 完成 |
| 会话管理 | 会话生命周期 | ✅ 完成 |
| 会话管理 | 查询管理 | ✅ 完成 |

### 5.2 待完善功能

| 模块 | 功能 | 优先级 |
|------|------|--------|
| 事务系统 | ACID 保证 | P0 |
| 事务系统 | 并发控制 | P0 |
| 索引系统 | 查询优化 | P1 |
| 索引系统 | 索引选择 | P1 |
| 网络协议 | 客户端协议 | P1 |
| 网络协议 | HTTP API | P1 |
| 监控统计 | 性能指标 | P2 |
| 监控统计 | 慢查询分析 | P2 |
| 备份恢复 | 数据备份 | P2 |
| 备份恢复 | 数据恢复 | P2 |

---

## 6. 总结

GraphDB 作为一个轻量级单节点图数据库，已经具备了图数据库的核心功能：

1. **完整的数据模型**: 支持节点、边、标签、属性等图数据库核心概念
2. **丰富的查询能力**: 支持 MATCH、GO、LOOKUP、FIND PATH 等多种查询方式
3. **完善的执行引擎**: 包含解析、验证、计划、优化、执行完整流程
4. **基础的权限管理**: 支持用户认证和角色权限控制
5. **灵活的存储接口**: 可插拔的存储引擎设计

适用于以下场景：
- 个人学习和原型开发
- 小规模应用的图数据存储
- 嵌入式图数据库需求
- 需要轻量级部署的场景

随着事务系统、网络协议、监控统计等功能的完善，GraphDB 将能够满足更多生产环境的需求。

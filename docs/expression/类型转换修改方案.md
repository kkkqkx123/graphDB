# AST表达式到核心表达式类型转换修改方案

## 概述

本方案提供了AST表达式到核心表达式类型转换系统的具体改进措施，包括类型映射完善、错误处理改进、代码重构等。

## 修改目标

1. **完善类型映射**：支持所有核心表达式类型
2. **改进错误处理**：使用结构化错误类型
3. **优化代码结构**：提高可读性和可维护性
4. **增强测试覆盖**：确保转换正确性

## 具体修改方案

### 1. 扩展AST表达式定义

**文件**：`src/query/parser/ast/expr.rs`

**修改内容**：
```rust
// 添加新的AST表达式类型以支持图数据库特有功能
#[derive(Debug, Clone, PartialEq)]
pub enum Expr {
    // 现有类型...
    Constant(ConstantExpr),
    Variable(VariableExpr),
    // ...
    
    // 新增类型
    TagProperty(TagPropertyExpr),      // 标签属性访问
    EdgeProperty(EdgePropertyExpr),     // 边属性访问
    InputProperty(InputPropertyExpr),   // 输入属性访问
    TypeCast(TypeCastExpr),            // 类型转换
    Range(RangeExpr),                  // 范围访问
    Path(PathExpr),                    // 路径构建
    Label(LabelExpr),                  // 标签
    ListComprehension(ListComprehensionExpr), // 列表推导
    Reduce(ReduceExpr),                // 归约表达式
    ESQuery(ESQueryExpr),              // 文本搜索
    UUID(UUIDExpr),                    // UUID生成
    MatchPathPattern(MatchPathPatternExpr), // 路径模式匹配
}

// 新增表达式结构定义
#[derive(Debug, Clone, PartialEq)]
pub struct TagPropertyExpr {
    pub span: Span,
    pub tag: String,
    pub property: String,
}

#[derive(Debug, Clone, PartialEq)]
pub struct EdgePropertyExpr {
    pub span: Span,
    pub edge: String,
    pub property: String,
}

// ... 其他新增表达式结构
```

### 2. 改进转换器实现

**文件**：`src/query/parser/expressions/expression_converter.rs`

#### 2.1 使用结构化错误类型

```rust
use crate::core::error::ExpressionError;

// 修改函数签名
pub fn convert_ast_to_graph_expression(ast_expr: &Expr) -> Result<Expression, ExpressionError> {
    // 实现...
}
```

#### 2.2 完善类型映射

```rust
fn convert_ast_to_graph_expression(ast_expr: &Expr) -> Result<Expression, ExpressionError> {
    match ast_expr {
        // 现有映射...
        Expr::Constant(expr) => convert_constant_expr(expr),
        Expr::Variable(expr) => convert_variable_expr(expr),
        // ...
        
        // 新增映射
        Expr::TagProperty(expr) => convert_tag_property_expr(expr),
        Expr::EdgeProperty(expr) => convert_edge_property_expr(expr),
        Expr::InputProperty(expr) => convert_input_property_expr(expr),
        Expr::TypeCast(expr) => convert_type_cast_expr(expr),
        Expr::Range(expr) => convert_range_expr(expr),
        Expr::Path(expr) => convert_path_expr(expr),
        Expr::Label(expr) => convert_label_expr(expr),
        Expr::ListComprehension(expr) => convert_list_comprehension_expr(expr),
        Expr::Reduce(expr) => convert_reduce_expr(expr),
        Expr::ESQuery(expr) => convert_es_query_expr(expr),
        Expr::UUID(expr) => convert_uuid_expr(expr),
        Expr::MatchPathPattern(expr) => convert_match_path_pattern_expr(expr),
    }
}

// 新增转换函数
fn convert_tag_property_expr(expr: &TagPropertyExpr) -> Result<Expression, ExpressionError> {
    Ok(Expression::TagProperty {
        tag: expr.tag.clone(),
        prop: expr.property.clone(),
    })
}

fn convert_edge_property_expr(expr: &EdgePropertyExpr) -> Result<Expression, ExpressionError> {
    Ok(Expression::EdgeProperty {
        edge: expr.edge.clone(),
        prop: expr.property.clone(),
    })
}

// ... 其他转换函数
```

#### 2.3 改进操作符支持

```rust
fn convert_binary_op(op: &BinaryOp) -> Result<BinaryOperator, ExpressionError> {
    match op {
        // 现有映射...
        BinaryOp::Add => Ok(BinaryOperator::Add),
        // ...
        
        // 改进XOR操作符支持
        BinaryOp::Xor => {
            // 方案1：提供替代实现
            // Ok(BinaryOperator::Xor) // 如果核心表达式支持XOR
            
            // 方案2：提供更好的错误信息
            Err(ExpressionError::unsupported_operation(
                "XOR操作符",
                "请使用 (a OR b) AND NOT (a AND b) 作为替代"
            ))
        }
    }
}
```

#### 2.4 简化CASE表达式转换

```rust
fn convert_case_expr(expr: &CaseExpr) -> Result<Expression, ExpressionError> {
    let conditions: Result<Vec<(Expression, Expression)>, ExpressionError> = expr
        .when_then_pairs
        .iter()
        .map(|(when, then)| {
            let when_expr = convert_ast_to_graph_expression(when)?;
            let then_expr = convert_ast_to_graph_expression(then)?;
            Ok((when_expr, then_expr))
        })
        .collect();

    let default = if let Some(ref default_expr) = expr.default {
        Some(Box::new(convert_ast_to_graph_expression(default_expr)?))
    } else {
        None
    };

    // 简化match表达式处理
    if let Some(ref match_expr) = expr.match_expr {
        let match_expr = convert_ast_to_graph_expression(match_expr)?;
        let new_conditions = conditions?
            .into_iter()
            .map(|(when, then)| {
                let condition = Expression::Binary {
                    left: Box::new(match_expr.clone()),
                    op: BinaryOperator::Equal,
                    right: Box::new(when),
                };
                (condition, then)
            })
            .collect();

        Ok(Expression::Case {
            conditions: new_conditions,
            default,
        })
    } else {
        Ok(Expression::Case {
            conditions: conditions?,
            default,
        })
    }
}
```

#### 2.5 改进聚合函数识别

```rust
fn convert_function_call_expr(expr: &FunctionCallExpr) -> Result<Expression, ExpressionError> {
    let args: Result<Vec<Expression>, ExpressionError> = expr
        .args
        .iter()
        .map(|arg| convert_ast_to_graph_expression(arg))
        .collect();

    let args = args?;

    // 使用更健壮的聚合函数识别
    let func_name = expr.name.to_uppercase();
    if is_aggregate_function(&func_name) {
        if args.len() != 1 {
            return Err(ExpressionError::invalid_argument_count(
                &func_name,
                1,
                args.len()
            ));
        }
        let arg = Box::new(args[0].clone());
        let aggregate_func = convert_aggregate_function(&func_name)?;

        Ok(Expression::Aggregate {
            func: aggregate_func,
            arg,
            distinct: expr.distinct,
        })
    } else {
        Ok(Expression::Function {
            name: expr.name.clone(),
            args,
        })
    }
}

// 改进聚合函数识别
fn is_aggregate_function(func_name: &str) -> bool {
    // 使用常量集合提高性能
    const AGGREGATE_FUNCTIONS: &[&str] = &[
        "COUNT", "SUM", "AVG", "MIN", "MAX", "COLLECT", "DISTINCT"
    ];
    
    AGGREGATE_FUNCTIONS.contains(&func_name)
}
```

### 3. 创建错误处理改进

**文件**：`src/core/error.rs`

```rust
// 扩展ExpressionError类型
#[derive(Debug, Clone, PartialEq)]
pub enum ExpressionError {
    UnsupportedOperation {
        operation: String,
        suggestion: String,
    },
    InvalidArgumentCount {
        function: String,
        expected: usize,
        actual: usize,
    },
    TypeMismatch {
        expected: String,
        actual: String,
    },
    // 现有错误类型...
}

impl ExpressionError {
    pub fn unsupported_operation(operation: &str, suggestion: &str) -> Self {
        ExpressionError::UnsupportedOperation {
            operation: operation.to_string(),
            suggestion: suggestion.to_string(),
        }
    }
    
    pub fn invalid_argument_count(function: &str, expected: usize, actual: usize) -> Self {
        ExpressionError::InvalidArgumentCount {
            function: function.to_string(),
            expected,
            actual,
        }
    }
    
    pub fn type_mismatch(expected: &str, actual: &str) -> Self {
        ExpressionError::TypeMismatch {
            expected: expected.to_string(),
            actual: actual.to_string(),
        }
    }
}
```

## 实施计划

### 阶段1：错误处理改进（1-2天）
1. 扩展ExpressionError类型
2. 修改转换器使用新的错误类型
3. 更新相关测试

### 阶段2：类型映射完善（3-5天）
1. 扩展AST表达式定义
2. 实现新的转换函数
3. 添加对应的解析器支持

### 阶段3：代码优化（2-3天）
1. 重构复杂转换逻辑
2. 优化性能关键路径
3. 改进错误消息

### 阶段4：测试覆盖（2-3天）
1. 为所有新功能添加单元测试
2. 添加集成测试
3. 性能测试和基准测试

## 预期效果

### 功能改进
- 支持所有图数据库特有表达式类型
- 提供更好的错误信息和用户体验
- 提高系统的功能完整性

### 代码质量改进
- 提高代码可读性和可维护性
- 增强类型安全性
- 改善错误处理机制

### 性能改进
- 优化聚合函数识别性能
- 减少不必要的内存分配
- 提高转换效率

## 风险评估

### 技术风险
- **低风险**：错误处理改进和代码优化
- **中风险**：类型映射扩展（需要修改解析器）
- **高风险**：新增表达式类型的语法解析

### 缓解措施
- 分阶段实施，每个阶段都有测试验证
- 保持向后兼容性
- 充分的测试覆盖

## 验收标准

1. 所有核心表达式类型都有对应的AST映射
2. 错误处理使用结构化错误类型
3. 转换器代码通过所有测试
4. 性能基准测试显示无性能下降
5. 新增功能有完整的测试覆盖
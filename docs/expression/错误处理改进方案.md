# 表达式类型转换错误处理改进方案

## 概述

本方案详细描述了如何改进AST表达式到核心表达式类型转换过程中的错误处理机制，从简单的字符串错误升级为结构化错误类型。

## 当前问题分析

### 现有错误处理方式

**文件**：`src/query/parser/expressions/expression_converter.rs`

```rust
// 当前使用简单的字符串错误
pub fn convert_ast_to_graph_expression(ast_expr: &Expr) -> Result<Expression, String> {
    // 实现...
}

// 错误返回示例
fn convert_binary_op(op: &BinaryOp) -> Result<BinaryOperator, String> {
    match op {
        BinaryOp::Xor => Err("XOR操作符在graph表达式中不支持".to_string()),
        // ...
    }
}
```

### 问题分析

1. **缺乏结构化信息**：错误信息难以程序化处理
2. **错误分类缺失**：无法区分不同类型的错误
3. **定位困难**：缺乏错误上下文和位置信息
4. **用户体验差**：错误信息不够友好和详细

## 改进方案

### 1. 扩展错误类型定义

**文件**：`src/core/error.rs`

```rust
use std::fmt;

/// 表达式错误类型
#[derive(Debug, Clone, PartialEq)]
pub enum ExpressionError {
    /// 不支持的操作
    UnsupportedOperation {
        operation: String,
        suggestion: String,
        context: Option<String>,
    },
    
    /// 参数数量错误
    InvalidArgumentCount {
        function: String,
        expected: usize,
        actual: usize,
        context: Option<String>,
    },
    
    /// 类型不匹配
    TypeMismatch {
        expected: String,
        actual: String,
        context: Option<String>,
    },
    
    /// 语法错误
    SyntaxError {
        message: String,
        position: Option<Span>,
    },
    
    /// 语义错误
    SemanticError {
        message: String,
        context: Option<String>,
    },
    
    /// 转换错误
    ConversionError {
        from_type: String,
        to_type: String,
        reason: String,
    },
    
    /// 内部错误
    InternalError {
        message: String,
        details: Option<String>,
    },
}

impl ExpressionError {
    /// 创建不支持的操作错误
    pub fn unsupported_operation(operation: &str, suggestion: &str) -> Self {
        ExpressionError::UnsupportedOperation {
            operation: operation.to_string(),
            suggestion: suggestion.to_string(),
            context: None,
        }
    }
    
    /// 创建带上下文的不支持操作错误
    pub fn unsupported_operation_with_context(
        operation: &str, 
        suggestion: &str, 
        context: &str
    ) -> Self {
        ExpressionError::UnsupportedOperation {
            operation: operation.to_string(),
            suggestion: suggestion.to_string(),
            context: Some(context.to_string()),
        }
    }
    
    /// 创建参数数量错误
    pub fn invalid_argument_count(function: &str, expected: usize, actual: usize) -> Self {
        ExpressionError::InvalidArgumentCount {
            function: function.to_string(),
            expected,
            actual,
            context: None,
        }
    }
    
    /// 创建类型不匹配错误
    pub fn type_mismatch(expected: &str, actual: &str) -> Self {
        ExpressionError::TypeMismatch {
            expected: expected.to_string(),
            actual: actual.to_string(),
            context: None,
        }
    }
    
    /// 创建语法错误
    pub fn syntax_error(message: &str, position: Option<Span>) -> Self {
        ExpressionError::SyntaxError {
            message: message.to_string(),
            position,
        }
    }
    
    /// 创建转换错误
    pub fn conversion_error(from_type: &str, to_type: &str, reason: &str) -> Self {
        ExpressionError::ConversionError {
            from_type: from_type.to_string(),
            to_type: to_type.to_string(),
            reason: reason.to_string(),
        }
    }
}

impl fmt::Display for ExpressionError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ExpressionError::UnsupportedOperation { operation, suggestion, context } => {
                if let Some(ctx) = context {
                    write!(f, "不支持的操作 '{}' (上下文: {}). 建议: {}", operation, ctx, suggestion)
                } else {
                    write!(f, "不支持的操作 '{}'. 建议: {}", operation, suggestion)
                }
            }
            ExpressionError::InvalidArgumentCount { function, expected, actual, context } => {
                if let Some(ctx) = context {
                    write!(f, "函数 '{}' 需要 {} 个参数，但提供了 {} 个 (上下文: {})", 
                           function, expected, actual, ctx)
                } else {
                    write!(f, "函数 '{}' 需要 {} 个参数，但提供了 {} 个", 
                           function, expected, actual)
                }
            }
            ExpressionError::TypeMismatch { expected, actual, context } => {
                if let Some(ctx) = context {
                    write!(f, "类型不匹配: 期望 {}, 实际 {} (上下文: {})", expected, actual, ctx)
                } else {
                    write!(f, "类型不匹配: 期望 {}, 实际 {}", expected, actual)
                }
            }
            ExpressionError::SyntaxError { message, position } => {
                if let Some(pos) = position {
                    write!(f, "语法错误: {} (位置: {:?})", message, pos)
                } else {
                    write!(f, "语法错误: {}", message)
                }
            }
            ExpressionError::SemanticError { message, context } => {
                if let Some(ctx) = context {
                    write!(f, "语义错误: {} (上下文: {})", message, ctx)
                } else {
                    write!(f, "语义错误: {}", message)
                }
            }
            ExpressionError::ConversionError { from_type, to_type, reason } => {
                write!(f, "转换错误: 从 {} 到 {} 失败 - {}", from_type, to_type, reason)
            }
            ExpressionError::InternalError { message, details } => {
                if let Some(dets) = details {
                    write!(f, "内部错误: {} (详情: {})", message, dets)
                } else {
                    write!(f, "内部错误: {}", message)
                }
            }
        }
    }
}

impl std::error::Error for ExpressionError {}

// 为方便使用，提供错误转换
impl From<ExpressionError> for DBError {
    fn from(err: ExpressionError) -> Self {
        DBError::Expression(err)
    }
}
```

### 2. 修改转换器使用新的错误类型

**文件**：`src/query/parser/expressions/expression_converter.rs`

```rust
use crate::core::error::ExpressionError;

// 修改函数签名
pub fn convert_ast_to_graph_expression(ast_expr: &Expr) -> Result<Expression, ExpressionError> {
    match ast_expr {
        // 现有映射...
        Expr::Constant(expr) => convert_constant_expr(expr),
        Expr::Variable(expr) => convert_variable_expr(expr),
        // ...
        
        // 使用新的错误类型
        _ => Err(ExpressionError::conversion_error(
            "AST表达式",
            "核心表达式",
            "尚未实现的转换"
        )),
    }
}

// 改进操作符转换错误处理
fn convert_binary_op(op: &BinaryOp) -> Result<BinaryOperator, ExpressionError> {
    match op {
        BinaryOp::Xor => Err(ExpressionError::unsupported_operation(
            "XOR操作符",
            "请使用 (a OR b) AND NOT (a AND b) 作为替代"
        )),
        
        BinaryOp::Add => Ok(BinaryOperator::Add),
        // ... 其他操作符
        
        _ => Err(ExpressionError::conversion_error(
            "AST二元操作符",
            "核心二元操作符",
            "未知的操作符类型"
        )),
    }
}

// 改进聚合函数错误处理
fn convert_function_call_expr(expr: &FunctionCallExpr) -> Result<Expression, ExpressionError> {
    let args: Result<Vec<Expression>, ExpressionError> = expr
        .args
        .iter()
        .map(|arg| convert_ast_to_graph_expression(arg))
        .collect();

    let args = args?;

    let func_name = expr.name.to_uppercase();
    if is_aggregate_function(&func_name) {
        if args.len() != 1 {
            return Err(ExpressionError::invalid_argument_count(
                &func_name,
                1,
                args.len()
            ));
        }
        // ... 其他逻辑
    }
    // ... 其他逻辑
}
```

### 3. 添加错误上下文信息

```rust
// 在转换过程中添加上下文信息
fn convert_case_expr(expr: &CaseExpr) -> Result<Expression, ExpressionError> {
    let mut conditions = Vec::new();

    for (i, (when, then)) in expr.when_then_pairs.iter().enumerate() {
        let when_expr = convert_ast_to_graph_expression(when)
            .map_err(|e| ExpressionError::SemanticError {
                message: format!("转换WHEN表达式失败 (第{}个条件)", i + 1),
                context: Some(format!("表达式: {:?}", when)),
            })?;
            
        let then_expr = convert_ast_to_graph_expression(then)
            .map_err(|e| ExpressionError::SemanticError {
                message: format!("转换THEN表达式失败 (第{}个条件)", i + 1),
                context: Some(format!("表达式: {:?}", then)),
            })?;
            
        conditions.push((when_expr, then_expr));
    }
    
    // ... 其他逻辑
}
```

### 4. 创建错误处理工具函数

```rust
// 错误处理辅助函数
pub trait ErrorContext {
    fn with_context<S: Into<String>>(self, context: S) -> Self;
}

impl<T> ErrorContext for Result<T, ExpressionError> {
    fn with_context<S: Into<String>>(self, context: S) -> Self {
        self.map_err(|err| match err {
            ExpressionError::UnsupportedOperation { operation, suggestion, .. } => {
                ExpressionError::unsupported_operation_with_context(&operation, &suggestion, &context.into())
            }
            ExpressionError::InvalidArgumentCount { function, expected, actual, .. } => {
                ExpressionError::InvalidArgumentCount {
                    function,
                    expected,
                    actual,
                    context: Some(context.into()),
                }
            }
            // ... 其他错误类型的上下文处理
            _ => err,
        })
    }
}

// 使用示例
fn convert_complex_expression(expr: &Expr) -> Result<Expression, ExpressionError> {
    convert_ast_to_graph_expression(expr)
        .with_context("复杂表达式转换")
}
```

## 实施步骤

### 阶段1：错误类型定义（1天）
1. 扩展ExpressionError枚举
2. 实现Display和Error trait
3. 添加构造函数

### 阶段2：转换器修改（2天）
1. 修改所有转换函数签名
2. 替换字符串错误为ExpressionError
3. 添加错误上下文信息

### 阶段3：错误处理工具（1天）
1. 实现错误上下文工具
2. 添加错误链支持
3. 创建错误格式化工具

### 阶段4：测试和验证（1天）
1. 更新现有测试
2. 添加错误处理测试
3. 验证错误消息质量

## 预期效果

### 错误信息质量提升
- **结构化信息**：程序可以解析和处理错误
- **详细上下文**：包含错误发生的位置和上下文
- **友好建议**：提供解决问题的具体建议

### 开发体验改善
- **调试便利**：错误信息包含完整的调用链
- **错误分类**：可以按错误类型进行过滤和处理
- **测试友好**：可以针对特定错误类型编写测试

### 系统稳定性增强
- **错误恢复**：可以根据错误类型采取不同恢复策略
- **监控支持**：可以统计和分析不同类型的错误
- **日志优化**：错误日志包含结构化信息

## 兼容性考虑

### 向后兼容性
- 保持现有API不变，只修改内部实现
- 新增错误类型不影响现有错误处理逻辑
- 逐步迁移，确保平稳过渡

### 向前兼容性
- 错误类型设计考虑未来扩展
- 错误消息格式保持稳定
- 提供错误版本信息

## 验收标准

1. 所有转换函数使用ExpressionError类型
2. 错误信息包含足够的上下文信息
3. 错误处理工具函数正常工作
4. 现有测试通过，新增错误处理测试
5. 错误消息对用户友好且具有指导性
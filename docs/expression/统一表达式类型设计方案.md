# 统一表达式类型设计方案

## 一、执行摘要

本文档描述了 GraphDB 项目中表达式类型的统一设计方案。当前系统存在两个独立的 `Expression` 类型（`parser::ast::Expression` 和 `core::types::expression::Expression`），这种设计导致类型转换开销、集成复杂度和代码维护困难等问题。

本方案采用分层统一架构，通过四个阶段的渐进式迁移，最终实现单一、统一、可复用的表达式类型体系。

**核心指标**：
- 实施周期：8-10 周
- 预期收益：消除类型转换开销、简化代码结构、提高可维护性
- 风险等级：中等（通过渐进式迁移控制）

## 二、现状分析

### 2.1 双类型设计现状

当前项目中存在两个独立的表达式类型定义，各自承担不同的职责：

| 类型定义 | 文件位置 | 核心职责 | 特点 |
|----------|----------|----------|------|
| `parser::ast::Expression` | `src/query/parser/ast/expression.rs` | 语法分析阶段 | 结构化变体、包含 Span、便于错误定位 |
| `core::types::expression::Expression` | `src/core/types/expression.rs` | 执行与序列化 | 扁平枚举、支持 serde、高性能 |

两个类型的变体结构对比如下：

```
parser::ast::Expression          core::Expression
├── Constant(ConstantExpression) ├── Literal(Value)
├── Variable(VariableExpression) ├── Variable(String)
├── Binary(BinaryExpression)     ├── Binary { left, op, right }
├── Unary(UnaryExpression)       ├── Unary { op, operand }
├── FunctionCall(...)            ├── Function { name, args }
├── PropertyAccess(...)          ├── Property { object, property }
├── List(...)                    ├── List(Vec<Expression>)
├── Map(...)                     ├── Map(Vec<(String, Expression)>)
├── Case(...)                    ├── Case { conditions, default }
├── Subscript(...)               ├── Subscript { collection, index }
├── TypeCast(...)                ├── TypeCast { expression, target_type }
├── Range(...)                   ├── Range { collection, start, end }
├── Path(...)                    ├── Path(Vec<Expression>)
└── Label(...)                   ├── Label(String)
```

### 2.2 当前集成流程

当前查询处理流程中，表达式类型在不同阶段之间需要进行转换：

```
用户查询字符串
        ↓
┌─────────────────────────────────────────┐
│ Parser                                  │
│ 输入: &str                              │
│ 输出: parser::ast::Expression           │
└─────────────────────────────────────────┘
        ↓ convert_ast_to_graph_expression()
┌─────────────────────────────────────────┐
│ Validator                               │
│ 输入: core::Expression                  │
│ 输出: 验证结果                          │
└─────────────────────────────────────────┘
        ↓ 直接使用
┌─────────────────────────────────────────┐
│ Planner                                 │
│ 输入: parser::ast::Expression           │
│ 输出: 转换后使用 core::Expression       │
└─────────────────────────────────────────┘
        ↓ 直接使用
┌─────────────────────────────────────────┐
│ Executor                                │
│ 输入: core::Expression                  │
│ 输出: 执行结果                          │
└─────────────────────────────────────────┘
```

### 2.3 存在的问题

#### 2.3.1 类型转换开销

在多个位置需要调用 `convert_ast_to_graph_expression()` 函数进行类型转换：

**关键转换点**：

| 文件 | 行号 | 转换函数调用 | 影响 |
|------|------|--------------|------|
| `expressions/expression_converter.rs` | 69 | `convert_ast_to_graph_expression()` | 主转换函数 |
| `planner/plan/core/nodes/factory.rs` | 27 | `create_filter()` | 创建过滤节点 |
| `planner/plan/core/nodes/factory.rs` | 58 | `create_inner_join()` | 创建连接节点 |
| `executor/factory.rs` | 73 | `parse_expression_safe()` | 表达式解析 |

每次转换都需要：
- 遍历整个表达式树
- 为每个节点创建新实例
- 分配新内存

#### 2.3.2 类型不一致导致的集成困难

**典型问题场景**（`validator/structs/clause_structs.rs:114`）：

```rust
pub struct YieldColumn {
    pub expression: Expression,  // core::Expression
    pub alias: String,
}

// 但 factory 函数接收不同类型
pub fn create_filter(
    input: PlanNodeEnum,
    condition: Expression,  // parser::ast::Expression
) -> Result<PlanNodeEnum, ...>
```

这种类型不一致导致：
- 开发者需要始终关注当前使用的 Expression 类型
- 编译时类型检查无法捕获所有集成错误
- 代码可读性和可维护性降低

#### 2.3.3 Visitor 模式双重维护

项目维护了两套独立的表达式访问者实现：

| Visitor | 文件 | 针对类型 | 实现复杂度 |
|---------|------|----------|------------|
| `ExprVisitor` | `parser/ast/visitor.rs` | parser::ast::Expression | 访问独立 Struct 变体 |
| `ExpressionVisitor` | `core/expression_visitor.rs` | core::Expression | 访问扁平枚举变体 |

任何新的表达式类型或操作符都需要在两个文件中同步实现，增加了维护成本和出错风险。

#### 2.3.4 现有文档记录

项目文档已识别此问题，详见 `docs/expression/AST到核心表达式类型转换分析报告.md`，其中指出：

- 类型映射不完整
- 错误处理机制不完善
- 复杂转换逻辑可读性差

## 三、目标架构

### 3.1 分层统一架构设计

采用分层统一架构，定义清晰的职责边界：

```
┌─────────────────────────────────────────────────────────────────────┐
│                          表现层（Parser AST）                         │
├─────────────────────────────────────────────────────────────────────┤
│  职责：语法分析、错误定位                                              │
│  输入：查询字符串                                                     │
│  输出：RichExpression（含 Span）                                      │
│  特点：结构化、保留源码位置信息                                        │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────┐
│                          核心层（Core Expression）                    │
├─────────────────────────────────────────────────────────────────────┤
│  职责：类型检查、执行、序列化                                          │
│  输入：统一表达式                                                     │
│  输出：执行结果                                                       │
│  特点：简洁高效、支持 serde                                           │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────┐
│                          扩展层（Rich Expression）                    │
├─────────────────────────────────────────────────────────────────────┤
│  职责：元数据管理、表达式复用、错误报告                                │
│  包装：核心表达式 + 元数据                                            │
│  字段：span（位置）、id（缓存）、inner（表达式）                       │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 RichExpression 详细设计

#### 3.2.1 类型定义

```rust
// src/core/types/expression/rich.rs

use serde::{Deserialize, Serialize};
use std::sync::Arc;

/// 表达式 ID，用于缓存和追踪
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ExpressionId(pub u64);

/// 富表达式类型
///
/// 核心表达式的包装器，提供：
/// - 位置信息（用于错误报告）
/// - 表达式 ID（用于缓存）
/// - 表达式复用（Arc）
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(from = "RichExpressionSerde", into = "RichExpressionSerde")]
pub struct RichExpression {
    inner: Arc<Expression>,
    span: Option<Span>,
    id: Option<ExpressionId>,
}

/// 序列化辅助结构
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct RichExpressionSerde {
    inner: Expression,
    has_span: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    span_line: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    span_column: Option<u32>,
}

impl RichExpression {
    /// 创建新的富表达式（不包含位置信息）
    pub fn new(inner: Expression) -> Self {
        Self {
            inner: Arc::new(inner),
            span: None,
            id: None,
        }
    }

    /// 创建并设置位置信息
    pub fn with_span(inner: Expression, span: Span) -> Self {
        Self {
            inner: Arc::new(inner),
            span: Some(span),
            id: None,
        }
    }

    /// 获取位置信息
    pub fn span(&self) -> Option<&Span> {
        self.span.as_ref()
    }

    /// 获取表达式 ID
    pub fn id(&self) -> Option<&ExpressionId> {
        self.id.as_ref()
    }

    /// 获取内部引用
    pub fn inner(&self) -> &Expression {
        &self.inner
    }

    /// 克隆内部表达式（不克隆 Span）
    pub fn into_inner(self) -> Expression {
        self.inner.as_ref().clone()
    }

    /// 获取可变内部引用（需要克隆整个表达式）
    pub fn make_mut(&mut self) -> &mut Expression {
        if Arc::get_mut(&mut self.inner).is_none() {
            self.inner = Arc::new(self.inner.as_ref().clone());
        }
        Arc::get_mut(&mut self.inner).unwrap()
    }

    /// 检查是否为字面量
    pub fn is_literal(&self) -> bool {
        self.inner.is_literal()
    }

    /// 获取字面量值
    pub fn as_literal(&self) -> Option<&Value> {
        self.inner.as_literal()
    }

    /// 检查是否为变量
    pub fn is_variable(&self) -> bool {
        self.inner.is_variable()
    }

    /// 获取变量名
    pub fn as_variable(&self) -> Option<&str> {
        self.inner.as_variable()
    }

    /// 检查是否为聚合表达式
    pub fn is_aggregate(&self) -> bool {
        self.inner.is_aggregate()
    }

    /// 转换为字符串表示
    pub fn to_expression_string(&self) -> String {
        self.inner.to_expression_string()
    }
}

/// 从 RichExpression 提取核心表达式
impl From<RichExpression> for Expression {
    fn from(rich: RichExpression) -> Self {
        rich.into_inner()
    }
}

/// 从核心表达式创建
impl From<Expression> for RichExpression {
    fn from(expr: Expression) -> Self {
        RichExpression::new(expr)
    }
}

/// 为 RichExpression 实现 PartialEq（比较内部表达式）
impl PartialEq for RichExpression {
    fn eq(&self, other: &Self) -> bool {
        self.inner == other.inner
    }
}

/// 序列化实现
impl From<RichExpressionSerde> for RichExpression {
    fn from(s: RichExpressionSerde) -> Self {
        let span = if s.has_span {
            Some(Span::new(
                Position::new(s.span_line.unwrap_or(0), s.span_column.unwrap_or(0)),
                Position::new(s.span_line.unwrap_or(0), s.span_column.unwrap_or(0)),
            ))
        } else {
            None
        };
        Self {
            inner: Arc::new(s.inner),
            span,
            id: None,
        }
    }
}

impl From<RichExpression> for RichExpressionSerde {
    fn from(r: RichExpression) -> Self {
        Self {
            inner: r.inner.as_ref().clone(),
            has_span: r.span.is_some(),
            span_line: r.span.as_ref().map(|s| s.start.line),
            span_column: r.span.as_ref().map(|s| s.start.column),
        }
    }
}
```

#### 3.2.2 统一访问者接口

```rust
// src/core/types/expression/visitor.rs

use crate::core::types::expression::{BinaryOperator, Expression, UnaryOperator, Value};

/// 统一表达式访问者 trait
///
/// 支持访问核心表达式和可选的 Span 信息
pub trait RichExprVisitor<R = Result<Value, ExpressionError>> {
    /// 访问字面量
    fn visit_literal(&mut self, value: &Value, span: Option<&Span>) -> R;

    /// 访问变量
    fn visit_variable(&mut self, name: &str, span: Option<&Span>) -> R;

    /// 访问属性访问
    fn visit_property(&mut self, object: &Expression, property: &str, span: Option<&Span>) -> R;

    /// 访问二元运算
    fn visit_binary(
        &mut self,
        left: &Expression,
        op: &BinaryOperator,
        right: &Expression,
        span: Option<&Span>,
    ) -> R;

    /// 访问一元运算
    fn visit_unary(&mut self, op: &UnaryOperator, operand: &Expression, span: Option<&Span>) -> R;

    /// 访问函数调用
    fn visit_function(&mut self, name: &str, args: &[Expression], span: Option<&Span>) -> R;

    /// 访问聚合函数
    fn visit_aggregate(
        &mut self,
        func: &AggregateFunction,
        arg: &Expression,
        distinct: bool,
        span: Option<&Span>,
    ) -> R;

    /// 访问列表
    fn visit_list(&mut self, items: &[Expression], span: Option<&Span>) -> R;

    /// 访问映射
    fn visit_map(&mut self, pairs: &[(String, Expression)], span: Option<&Span>) -> R;

    /// 访问 CASE 表达式
    fn visit_case(
        &mut self,
        conditions: &[(Expression, Expression)],
        default: Option<&Expression>,
        span: Option<&Span>,
    ) -> R;

    /// 访问类型转换
    fn visit_type_cast(&mut self, expression: &Expression, target_type: &DataType, span: Option<&Span>) -> R;

    /// 访问下标访问
    fn visit_subscript(&mut self, collection: &Expression, index: &Expression, span: Option<&Span>) -> R;

    /// 访问范围表达式
    fn visit_range(
        &mut self,
        collection: &Expression,
        start: Option<&Expression>,
        end: Option<&Expression>,
        span: Option<&Span>,
    ) -> R;

    /// 访问路径表达式
    fn visit_path(&mut self, items: &[Expression], span: Option<&Span>) -> R;

    /// 访问标签表达式
    fn visit_label(&mut self, name: &str, span: Option<&Span>) -> R;

    /// 统一的访问入口
    fn visit(&mut self, expr: &RichExpression) -> R {
        let span = expr.span();
        self.visit_expression(&expr.inner, span)
    }

    /// 访问核心表达式
    fn visit_expression(&mut self, expr: &Expression, span: Option<&Span>) -> R {
        match expr {
            Expression::Literal(v) => self.visit_literal(v, span),
            Expression::Variable(n) => self.visit_variable(n, span),
            Expression::Property { object, property } => self.visit_property(object, property, span),
            Expression::Binary { left, op, right } => self.visit_binary(left, op, right, span),
            Expression::Unary { op, operand } => self.visit_unary(op, operand, span),
            Expression::Function { name, args } => self.visit_function(name, args, span),
            Expression::Aggregate { func, arg, distinct } => {
                self.visit_aggregate(func, arg, *distinct, span)
            }
            Expression::List(items) => self.visit_list(items, span),
            Expression::Map(pairs) => self.visit_map(pairs, span),
            Expression::Case { conditions, default } => self.visit_case(conditions, default.as_deref(), span),
            Expression::TypeCast { expression, target_type } => {
                self.visit_type_cast(expression, target_type, span)
            }
            Expression::Subscript { collection, index } => {
                self.visit_subscript(collection, index, span)
            }
            Expression::Range { collection, start, end } => {
                self.visit_range(collection, start.as_deref(), end.as_deref(), span)
            }
            Expression::Path(items) => self.visit_path(items, span),
            Expression::Label(name) => self.visit_label(name, span),
        }
    }
}
```

### 3.3 模块目录结构

统一后的模块目录结构：

```
src/core/types/
├── expression/
│   ├── mod.rs              # 模块入口，导出所有类型
│   ├── expression.rs       # 核心 Expression（已有）
│   ├── rich.rs             # RichExpression（新）
│   ├── span.rs             # Span 类型（新，从 parser 迁移）
│   ├── visitor.rs          # 统一 Visitor 接口（新）
│   ├── builder.rs          # 表达式构建器（可选）
│   └── tests/              # 测试模块
│       └── mod.rs
├── span.rs                 # 位置类型（临时，用于迁移）
├── mod.rs                  # 类型系统入口
├── operators.rs            # 操作符定义（已有）
├── graph_schema.rs         # 图模式（已有）
└── metadata.rs             # 元数据（已有）
```

**关键决策：Span 类型的位置**

Span 类型原位于 `parser::core::Span`，现迁移至 `core::types::Span`：

| 迁移前 | 迁移后 | 原因 |
|--------|--------|------|
| `parser::core::Span` | `core::types::Span` | Span 是通用位置类型，不应属于 parser |

**模块职责划分**

| 模块 | 职责 | 说明 |
|------|------|------|
| `core::types::Expression` | 核心表达式类型 | 执行层使用，支持序列化 |
| `core::types::RichExpression` | 富表达式包装器 | 包含 Span 等元数据 |
| `core::types::Span` | 源码位置类型 | 通用位置表示 |
| `core::types::ExpressionVisitor` | 统一访问者接口 | 支持泛型和特化模式 |
| `parser::ast::Expression` | AST 表达式类型 | 解析阶段使用，包含结构化变体 |
| `parser::ast::conversion` | 类型转换 | AST → Core 的转换实现 |

### 3.4 模块依赖关系

统一后的模块依赖关系：

```
┌─────────────────────────────────────────────────────────────────────┐
│                           parser 模块                                │
│                                                                      │
│  parser/ast/expression.rs ──uses──→ core::types::Span              │
│                                        ↑                            │
│  parser/ast/expression.rs ──uses──→ core::types::Expression        │
│                                        ↑                            │
│  parser/ast/conversion.rs ──uses──┘     │                          │
│                                        │                            │
│  parser/expressions/converter.rs ──uses┤                            │
│                                        │                            │
└────────────────────────────────────────┼────────────────────────────┘
                                         │
                                         ↓
┌─────────────────────────────────────────────────────────────────────┐
│                           core 模块                                  │
│                                                                      │
│  core/types/expression/                                              │
│  ├── mod.rs           ── 定义统一类型                                │
│  ├── expression.rs    ── 核心 Expression（已有）                    │
│  ├── rich.rs          ── RichExpression                             │
│  ├── span.rs          ── Span 类型（从 parser 迁移）                │
│  ├── visitor.rs       ── 统一访问者接口                              │
│  └── builder.rs       ── 表达式构建器（可选）                        │
│                                                                      │
│  core/expression_visitor.rs ── 更新为使用统一接口                     │
└─────────────────────────────────────────────────────────────────────┘
                                         │
                                         ↓
┌─────────────────────────────────────────────────────────────────────┐
│                         validator/planner/executor                    │
│                                                                      │
│  使用统一的 RichExpression 类型                                       │
│  移除重复的 Visitor 实现                                              │
└─────────────────────────────────────────────────────────────────────┘
```

**依赖原则**：
- 单向依赖：`parser` → `core`
- 无循环依赖
- `core` 模块自包含

## 四、分阶段实施方案

### 4.1 阶段一：基础设施建设（第 1-2 周）

**目标**：添加统一所需的基础设施，为后续迁移奠定基础。

#### 4.1.1 任务清单

| 任务编号 | 任务名称 | 文件路径 | 优先级 | 预估工时 |
|----------|----------|----------|--------|----------|
| P1.1 | 创建 Span 类型 | `src/core/types/expression/span.rs` | 高 | 0.5 天 |
| P1.2 | 创建 RichExpression | `src/core/types/expression/rich.rs` | 高 | 1 天 |
| P1.3 | 实现序列化支持 | `src/core/types/expression/serde.rs` | 高 | 0.5 天 |
| P1.4 | 创建统一 Visitor 接口 | `src/core/types/expression/visitor.rs` | 高 | 1 天 |
| P1.5 | 实现 From trait | `src/query/parser/ast/conversion.rs` | 高 | 0.5 天 |
| P1.6 | 更新 expression mod.rs | `src/core/types/expression/mod.rs` | 中 | 0.5 天 |
| P1.7 | 编写单元测试 | `src/core/types/expression/tests.rs` | 中 | 1 天 |
| P1.8 | 编译验证 | - | 高 | 0.5 天 |

#### 4.1.2 详细设计

**P1.1 Span 类型定义**：

```rust
// src/core/types/expression/span.rs

use serde::{Deserialize, Serialize};

/// 源码位置
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Position {
    pub line: u32,
    pub column: u32,
}

impl Position {
    pub fn new(line: u32, column: u32) -> Self {
        Self { line, column }
    }
}

/// 源码跨度（位置范围）
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Span {
    pub start: Position,
    pub end: Position,
}

impl Span {
    pub fn new(start: Position, end: Position) -> Self {
        Self { start, end }
    }

    pub fn default() -> Self {
        Self {
            start: Position::new(0, 0),
            end: Position::new(0, 0),
        }
    }

    pub fn to_string(&self) -> String {
        format!("{}:{}", self.start.line, self.start.column)
    }
}
```

**P1.2 RichExpression 实现**：

详见 3.2.1 节完整实现。

**P1.4 统一 Visitor 接口**：

详见 3.2.2 节完整实现。

**P1.5 From trait 实现**：

```rust
// src/query/parser/ast/conversion.rs

use crate::core::types::expression::Expression as CoreExpression;
use crate::query::parser::ast::Expression as ParserExpression;

/// 实现从 parser::ast::Expression 到 core::Expression 的转换
impl From<ParserExpression> for CoreExpression {
    fn from(ast: ParserExpression) -> Self {
        convert_ast_to_graph_expression(&ast)
            .expect("Expression conversion should not fail")
    }
}

/// 为引用实现转换
impl<'a> From<&'a ParserExpression> for CoreExpression {
    fn from(ast: &'a ParserExpression) -> Self {
        convert_ast_to_graph_expression(ast)
            .expect("Expression conversion should not fail")
    }
}

/// 批量转换
impl From<Vec<ParserExpression>> for Vec<CoreExpression> {
    fn from(vec: Vec<ParserExpression>) -> Self {
        vec.into_iter()
            .map(|expr| expr.into())
            .collect()
    }
}
```

#### 4.1.3 验收标准

- [ ] `cargo build` 通过，无错误
- [ ] RichExpression 支持序列化/反序列化
- [ ] From trait 转换正确
- [ ] 单元测试覆盖率达到 80% 以上

#### 4.1.4 风险与缓解

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| Span 类型与现有定义冲突 | 低 | 中 | 复用 `parser::core::Span` 定义 |
| 序列化兼容性问题 | 中 | 中 | 使用 Feature Flag 控制 |

---

### 4.2 阶段二：核心模块迁移（第 3-5 周）

**目标**：将核心模块（Validator、Planner）迁移到使用统一的表达式类型。

#### 4.2.1 任务清单

| 任务编号 | 任务名称 | 文件路径 | 优先级 | 预估工时 |
|----------|----------|----------|--------|----------|
| P2.1 | 更新 Validator YieldColumn | `src/query/validator/structs/clause_structs.rs` | 高 | 1 天 |
| P2.2 | 更新 Planner Factory | `src/query/planner/plan/core/nodes/factory.rs` | 高 | 1.5 天 |
| P2.3 | 更新 Executor Factory | `src/query/executor/factory.rs` | 高 | 1 天 |
| P2.4 | 统一 Visitor 实现 | `src/core/expression_visitor.rs` | 高 | 1.5 天 |
| P2.5 | 更新表达式构建器 | `src/core/types/expression/builder.rs` | 中 | 1 天 |
| P2.6 | 更新访问者实现 | `src/query/visitor/` 目录 | 高 | 2 天 |
| P2.7 | 集成测试 | - | 高 | 1 天 |
| P2.8 | 性能基准测试 | - | 中 | 1 天 |

#### 4.2.2 详细设计

**P2.1 更新 Validator 结构**：

```rust
// src/query/validator/structs/clause_structs.rs (修改后)

// 修改前
pub struct YieldColumn {
    pub expression: Expression,  // core::Expression
    pub alias: String,
    pub is_matched: bool,
}

// 修改后
pub struct YieldColumn {
    pub expression: RichExpression,
    pub alias: String,
    pub is_matched: bool,
}

// 更新相关方法
impl YieldColumn {
    pub fn new(expression: impl Into<RichExpression>, alias: String) -> Self {
        Self {
            expression: expression.into(),
            alias,
            is_matched: false,
        }
    }

    pub fn name(&self) -> &str {
        &self.alias
    }

    pub fn inner(&self) -> &Expression {
        self.expression.inner()
    }
}
```

**P2.2 更新 Planner Factory**：

```rust
// src/query/planner/plan/core/nodes/factory.rs (修改后)

use crate::core::types::expression::RichExpression;

// 修改前
pub fn create_filter(
    input: PlanNodeEnum,
    condition: Expression,  // parser::ast::Expression
) -> Result<PlanNodeEnum, PlannerError> {
    let expression = convert_ast_to_graph_expression(&condition)?;
    let filter_node = FilterNode::new(input, expression)?;
    Ok(PlanNodeEnum::Filter(filter_node))
}

// 修改后
pub fn create_filter(
    input: PlanNodeEnum,
    condition: impl Into<RichExpression>,
) -> Result<PlanNodeEnum, PlannerError> {
    let expression: Expression = condition.into().into();
    let filter_node = FilterNode::new(input, expression)?;
    Ok(PlanNodeEnum::Filter(filter_node))
}
```

**P2.3 更新 Executor Factory**：

```rust
// src/query/executor/factory.rs (修改后)

use crate::core::types::expression::RichExpression;

/// 修改前
fn parse_expression_safe(expr_str: &str) -> Option<crate::core::Expression> {
    crate::query::parser::expressions::parse_expression_from_string(expr_str)
        .inspect_err(|e| {
            log::warn!("Failed to parse expression: {}, error: {:?}", expr_str, e);
        })
        .ok()
}

/// 修改后
fn parse_expression_safe(expr_str: &str) -> Option<RichExpression> {
    crate::query::parser::expressions::parse_expression_from_string(expr_str)
        .map(|expr| expr.into())
        .inspect_err(|e| {
            log::warn!("Failed to parse expression: {}, error: {:?}", expr_str, e);
        })
        .ok()
}
```

**P2.4 统一 Visitor 实现**：

```rust
// src/core/expression_visitor.rs (修改后)

use crate::core::types::expression::RichExpression;

/// 更新后的 ExpressionVisitor
pub trait UnifiedExpressionVisitor {
    type Result;

    fn visit_literal(&mut self, value: &Value) -> Self::Result;
    fn visit_variable(&mut self, name: &str) -> Self::Result;
    fn visit_property(&mut self, object: &Expression, property: &str) -> Self::Result;
    // ... 其他方法（与 RichExprVisitor 保持一致）

    /// 新增：支持 RichExpression
    fn visit_rich(&mut self, rich: &RichExpression) -> Self::Result {
        self.visit_expression(rich.inner())
    }
}
```

#### 4.2.3 验收标准

- [ ] 所有使用 Expression 的模块编译通过
- [ ] Validator、Planner、Executor 功能正常
- [ ] 集成测试覆盖主要查询场景
- [ ] 性能基准测试显示无显著下降（< 5%）

#### 4.2.4 风险与缓解

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| 大量代码修改引入回归 | 高 | 高 | 增量修改，每完成一个文件运行测试 |
| Visitor 兼容性问题 | 中 | 高 | 保持旧接口，标记 deprecated |

---

### 4.3 阶段三：Parser 集成（第 6-7 周）

**目标**：Parser 直接产出 RichExpression，移除冗余转换。

#### 4.3.1 任务清单

| 任务编号 | 任务名称 | 文件路径 | 优先级 | 预估工时 |
|----------|----------|----------|--------|----------|
| P3.1 | 更新 Parser 返回类型 | `src/query/parser/parser/mod.rs` | 高 | 1 天 |
| P3.2 | 集成 Span 收集 | `src/query/parser/` 目录 | 高 | 2 天 |
| P3.3 | 更新表达式解析 | `src/query/parser/parser/expr_parser.rs` | 高 | 1.5 天 |
| P3.4 | 更新语句解析 | `src/query/parser/parser/stmt_parser.rs` | 中 | 1 天 |
| P3.5 | 移除旧转换函数 | `src/query/parser/expressions/` | 中 | 0.5 天 |
| P3.6 | 端到端测试 | - | 高 | 1 天 |

#### 4.3.2 详细设计

**P3.1 更新 Parser 返回类型**：

```rust
// src/query/parser/parser/mod.rs (修改后)

use crate::core::types::expression::RichExpression;

pub struct Parser<'a> {
    ctx: ParseContext<'a>,
}

impl<'a> Parser<'a> {
    pub fn new(input: &'a str) -> Self {
        Self {
            ctx: ParseContext::new(input),
        }
    }

    pub fn parse(&mut self) -> Result<RichExpression, ParseError> {
        let expr = self.parse_expression()?;
        let span = self.ctx.current_span();
        Ok(RichExpression::with_span(expr, span))
    }

    pub fn parse_statement(&mut self) -> Result<Stmt, ParseError> {
        // 语句解析保持不变，但表达式类型更新
        let mut stmt_parser = StmtParser::new();
        stmt_parser.parse_statement(&mut self.ctx)
    }

    pub fn parse_expression(&mut self) -> Result<Expression, ParseError> {
        // 内部仍使用 core::Expression
        let mut expr_parser = ExprParser::new(&self.ctx);
        expr_parser.parse_expression(&mut self.ctx)
    }
}
```

**P3.2 集成 Span 收集**：

在表达式的每个子元素解析时收集 Span：

```rust
// src/query/parser/parser/expr_parser.rs (修改后)

impl<'a> ExprParser<'a> {
    pub fn parse_expression(&mut self, ctx: &mut ParseContext<'a>) -> Result<Expression, ParseError> {
        let start_pos = ctx.current_position();
        let expr = self.parse_additive(ctx)?;
        let end_pos = ctx.current_position();

        // 为表达式添加位置信息
        if ctx.has_span_tracking() {
            let span = Span::new(start_pos, end_pos);
            Ok(RichExpression::with_span(expr, span).into())
        } else {
            Ok(expr)
        }
    }
}
```

#### 4.3.3 验收标准

- [ ] Parser 返回 RichExpression
- [ ] 错误消息包含准确的位置信息
- [ ] 端到端测试全部通过
- [ ] 旧转换函数可安全移除（标记为 deprecated）

#### 4.3.4 风险与缓解

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| Span 收集不完整 | 中 | 中 | 增加测试覆盖 |
| 性能影响 | 低 | 低 | 使用 Arc 共享表达式 |

---

### 4.4 阶段四：清理与优化（第 8-10 周）

**目标**：移除冗余代码，优化性能，完善文档。

#### 4.4.1 任务清单

| 任务编号 | 任务名称 | 文件路径 | 优先级 | 预估工时 |
|----------|----------|----------|--------|----------|
| P4.1 | 移除旧转换函数 | `src/query/parser/expressions/converter.rs` | 高 | 0.5 天 |
| P4.2 | 简化模块结构 | `src/query/parser/` 目录 | 中 | 1 天 |
| P4.3 | 性能优化 | - | 中 | 2 天 |
| P4.4 | 更新文档 | `docs/expression/` 目录 | 中 | 1 天 |
| P4.5 | 最终测试验证 | - | 高 | 1 天 |
| P4.6 | 编写迁移指南 | `docs/migration/` 目录 | 中 | 1 天 |

#### 4.4.2 详细设计

**P4.1 移除旧转换函数**：

```rust
// src/query/parser/expressions/converter.rs (修改后)

// 修改前
pub fn convert_ast_to_graph_expression(ast_expression: &Expression) -> Result<GraphExpression, String> {
    // ... 完整实现
}

// 修改后（标记为 deprecated）
#[deprecated(since = "2.0.0", note = "Use RichExpression instead")]
pub fn convert_ast_to_graph_expression(ast_expression: &Expression) -> Result<GraphExpression, String> {
    // 保留实现用于兼容
    Ok(ast_expression.clone())
}
```

**P4.3 性能优化**：

```rust
// 表达式复用优化
impl RichExpression {
    /// 从缓存获取或创建新表达式
    pub fn get_or_insert<F>(&mut self, f: F) -> &Expression
    where
        F: FnOnce() -> Expression,
    {
        let inner = Arc::make_mut(&mut self.inner);
        if inner.is_empty() {
            *inner = f();
        }
        inner
    }
}

/// 表达式池（可选优化）
pub struct ExpressionPool {
    inner: Mutex<Vec<Expression>>,
}

impl ExpressionPool {
    pub fn new() -> Self {
        Self {
            inner: Mutex::new(Vec::new()),
        }
    }

    pub fn get(&self, expr: &Expression) -> Expression {
        let mut pool = self.inner.lock().unwrap();
        if let Some(idx) = pool.iter().position(|e| e == expr) {
            pool.remove(idx)
        } else {
            expr.clone()
        }
    }

    pub fn put(&self, expr: Expression) {
        let mut pool = self.inner.lock().unwrap();
        if pool.len() < 100 {
            pool.push(expr);
        }
    }
}
```

#### 4.4.3 验收标准

- [ ] 无弃用的代码在关键路径使用
- [ ] 性能基准测试通过
- [ ] 文档更新完成
- [ ] 迁移指南可供团队参考

#### 4.4.4 风险与缓解

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| 遗漏清理 | 低 | 低 | 代码审查 |
| 性能未达预期 | 中 | 中 | 持续监控 |

---

## 五、测试策略

### 5.1 单元测试

每个模块应包含完整的单元测试：

```rust
// src/core/types/expression/tests.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rich_expression_creation() {
        let expr = Expression::literal(42);
        let rich = RichExpression::new(expr);
        assert!(rich.span().is_none());
    }

    #[test]
    fn test_rich_expression_with_span() {
        let expr = Expression::variable("x");
        let span = Span::new(Position::new(1, 0), Position::new(1, 1));
        let rich = RichExpression::with_span(expr, span);
        assert!(rich.span().is_some());
    }

    #[test]
    fn test_rich_expression_serde() {
        let expr = Expression::literal("test");
        let rich = RichExpression::new(expr);
        let json = serde_json::to_string(&rich).unwrap();
        let decoded: RichExpression = serde_json::from_str(&json).unwrap();
        assert_eq!(rich, decoded);
    }

    #[test]
_conversion() {
    fn test_expression        use crate::query::parser::ast::Expression as ParserExpr;

        let parser_expr = ParserExpr::Variable(
            crate::query::parser::ast::VariableExpression::new(
                "test".to_string(),
                Span::default(),
            )
        );
        let core_expr: CoreExpression = parser_expr.into();
        assert!(matches!(core_expr, CoreExpression::Variable(_)));
    }
}
```

### 5.2 集成测试

关键路径的端到端测试：

```rust
// tests/expression_unified.rs

#[cfg(test)]
mod tests {
    use crate::graphdb::prelude::*;

    #[tokio::test]
    async fn test_query_with_expression() -> DBResult<()> {
        let storage = setup_storage().await?;
        let mut executor = GraphQueryExecutor::new(storage);

        // 测试基本表达式
        let result = executor
            .execute("MATCH (n) WHERE n.age > 25 RETURN n.name")
            .await?;
        assert!(result.is_ok());

        // 测试复杂表达式
        let result = executor
            .execute("MATCH (n) WHERE n.score >= 60 AND n.status = 'active' RETURN n")
            .await?;
        assert!(result.is_ok());

        Ok(())
    }

    #[tokio::test]
    async fn test_error_location_reporting() {
        let storage = setup_storage().await?;
        let mut executor = GraphQueryExecutor::new(storage);

        // 测试错误位置信息
        let result = executor
            .execute("MATCH (n WHERE n.age > ) RETURN n")
            .await;

        assert!(result.is_err());
        let error = result.unwrap_err();
        assert!(error.to_string().contains("1:20")); // 期望的位置信息
    }
}
```

### 5.3 性能测试

```rust
// benches/expression_benches.rs

use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_expression_parsing(c: &mut Criterion) {
    let query = "MATCH (n) WHERE n.age > 25 AND n.score >= 60 RETURN n.name";

    c.bench_function("expression_parse", |b| {
        b.iter(|| {
            let mut parser = Parser::new(black_box(query));
            parser.parse()
        })
    });
}

fn bench_expression_clone(c: &mut Criterion) {
    let expr = Expression::binary(
        Expression::variable("a"),
        BinaryOperator::Add,
        Expression::variable("b"),
    );
    let rich = RichExpression::new(expr);

    c.bench_function("rich_expression_clone", |b| {
        b.iter(|| black_box(&rich).clone())
    });
}

criterion_group!(benches, bench_expression_parsing, bench_expression_clone);
criterion_main!(benches);
```

## 六、风险评估

### 6.1 技术风险

| 风险 | 可能性 | 影响 | 等级 | 缓解措施 |
|------|--------|------|------|----------|
| 性能下降 | 中 | 高 | 高 | 基准测试监控；使用 Arc 共享 |
| 回归问题 | 高 | 高 | 高 | 渐进式迁移；全面测试覆盖 |
| 依赖循环 | 低 | 高 | 中 | 严格依赖检查 |
| 序列化兼容性问题 | 中 | 中 | 中 | Feature Flag 控制 |

### 6.2 进度风险

| 风险 | 可能性 | 影响 | 等级 | 缓解措施 |
|------|--------|------|------|----------|
| 范围蔓延 | 中 | 中 | 中 | 明确阶段边界；拒绝临时需求 |
| 资源不足 | 低 | 中 | 低 | 预留缓冲时间 |
| 集成冲突 | 中 | 高 | 高 | 并行工作区；代码审查 |

### 6.3 风险缓解策略

1. **渐进式迁移**：每个阶段都是可工作的版本，可以随时回退
2. **Feature Flag**：使用 Cargo Feature 控制新旧实现切换
3. **持续集成**：每个提交都运行完整测试套件
4. **代码审查**：所有重大变更需要代码审查

## 七、成功标准

### 7.1 功能标准

- [ ] 所有现有查询功能正常工作
- [ ] 错误消息包含准确的位置信息
- [ ] 类型转换统一，消除冗余代码

### 7.2 性能标准

- [ ] 表达式解析性能无显著下降（< 5%）
- [ ] 内存使用合理（Arc 共享生效）
- [ ] 序列化性能满足需求

### 7.3 代码质量标准

- [ ] 单元测试覆盖率 > 80%
- [ ] 文档覆盖率 > 90%
- [ ] 无循环依赖
- [ ] Cargo Clippy 通过

### 7.4 进度标准

- [ ] 按计划完成四个阶段
- [ ] 每个阶段交付可工作的版本
- [ ] 团队完成迁移培训

## 八、附录

### 8.1 文件变更清单

| 文件路径 | 变更类型 | 说明 |
|----------|----------|------|
| `src/core/types/expression/mod.rs` | 修改 | 导出新类型 |
| `src/core/types/expression/span.rs` | 新增 | Span 类型 |
| `src/core/types/expression/rich.rs` | 新增 | RichExpression 类型 |
| `src/core/types/expression/visitor.rs` | 新增 | 统一 Visitor |
| `src/core/types/expression/builder.rs` | 新增 | 表达式构建器 |
| `src/query/parser/ast/conversion.rs` | 新增 | 类型转换 |
| `src/query/parser/expressions/converter.rs` | 修改 | 标记 deprecated |
| `src/query/validator/structs/clause_structs.rs` | 修改 | 使用 RichExpression |
| `src/query/planner/plan/core/nodes/factory.rs` | 修改 | 统一接口 |
| `src/query/executor/factory.rs` | 修改 | 统一接口 |

### 8.2 依赖变更

```toml
# Cargo.toml 无需修改
# 所有依赖通过现有路径引入
```

### 8.3 参考文档

- [AST 到核心表达式类型转换分析报告](../expression/AST到核心表达式类型转换分析报告.md)
- [类型系统重构总结](../type_system_refactor_summary.md)
- [模块职责分析](../module_responsibility_analysis.md)

### 8.4 版本历史

| 版本 | 日期 | 作者 | 说明 |
|------|------|------|------|
| 1.0 | 2024-01-26 | GraphDB Team | 初始版本 |

# Rust 存储库选择分析报告

## 概述

本文档分析了 Rust 生态系统中可用的嵌入式存储库，为 GraphDB 项目选择合适的存储引擎提供参考。

## 当前状态

项目当前使用 **sled 0.34.7** 作为存储引擎，配合 bincode 进行序列化。

### 当前实现特点

从 [native_storage.rs](../../src/storage/native_storage.rs) 可以看到：

- 使用多个 Tree 隔离数据（nodes, edges, schema, 索引等）
- 实现 LRU 缓存优化（vertex_cache, edge_cache）
- 支持事务管理（active_transactions）
- 实现属性索引（prop_index）
- 使用 bincode 进行序列化

## Rust 生态中的主要存储库

### 1. sled（当前使用）

#### 基本信息
- **版本**: 0.34.7
- **语言**: 纯 Rust
- **状态**: Beta（从未达到 1.0.0）
- **最后更新**: 约 3 年前

#### 优势
- ✅ 纯 Rust 实现，无外部 C 依赖
- ✅ API 简洁，类似 `BTreeMap<[u8], [u8]>`
- ✅ 使用 Bw-Tree 索引，无锁设计
- ✅ 自动调优，无需复杂配置
- ✅ 支持多 Tree（列族）隔离
- ✅ ACID 事务支持

#### 劣势
- ❌ 从未达到 1.0.0，仍处于 beta 阶段
- ❌ 社区活跃度下降
- ❌ 文档不够完善
- ❌ 可能存在 bug 和兼容性问题
- ❌ 生产环境使用案例较少

#### 适用场景
- 原型开发和测试
- 不需要长期维护的项目
- 对稳定性要求不高的场景

---

### 2. RocksDB (rust-rocksdb)

#### 基本信息
- **语言**: C++ 库的 Rust 绑定
- **状态**: 非常成熟
- **维护者**: Facebook
- **生产使用**: TiKV, Apache Flink, CockroachDB 等

#### 优势
- ✅ 非常成熟，广泛使用
- ✅ LSM-Tree 结构，写入性能极佳
- ✅ 丰富的配置选项
- ✅ 压缩、列族、备份等企业级功能
- ✅ 大量生产环境验证

#### 劣势
- ❌ C++ 库的 Rust 绑定
- ❌ 需要 C++ 编译器
- ❌ 配置复杂，需要性能调优
- ❌ 编译时间长
- ❌ API 不够 Rust 风格

#### 适用场景
- 生产环境
- 写入密集型应用
- 需要企业级功能的场景

---

### 3. LMDB (heed)

#### 基本信息
- **语言**: C 库的 Rust 绑定
- **状态**: 非常稳定
- **Rust 绑定**: heed

#### 优势
- ✅ 读取速度极快（内存映射设计）
- ✅ 极其稳定
- ✅ 单文件数据库
- ✅ 事务支持，ACID 保证

#### 劣势
- ❌ API 简陋
- ❌ 写入性能不如 LSM-Tree
- ❌ 文件大小限制（2TB）
- ❌ C 库绑定

#### 适用场景
- 读密集型应用
- 需要极致读取性能的场景

---

### 4. MDBX (libmdbx-rs)

#### 基本信息
- **语言**: C 库的 Rust 绑定
- **状态**: LMDB 的改进版本
- **Rust 绑定**: libmdbx-rs

#### 优势
- ✅ LMDB 的改进版本
- ✅ 更好的并发支持
- ✅ 更大的文件大小限制
- ✅ 读取性能极佳

#### 劣势
- ❌ C 库绑定
- ❌ 相对较新，使用案例较少

#### 适用场景
- 读密集型应用
- 需要更好的并发支持

---

### 5. redb

#### 基本信息
- **语言**: 纯 Rust
- **状态**: 活跃开发中
- **数据结构**: B+ 树

#### 优势
- ✅ 纯 Rust 实现
- ✅ 活跃开发，社区活跃
- ✅ 现代 API，类型安全
- ✅ 支持事务、多表
- ✅ 读写均衡

#### 劣势
- ❌ 相对较新
- ❌ 生产环境使用案例较少
- ❌ 生态系统还在发展中

#### 适用场景
- 希望保持纯 Rust 生态
- 愿意接受较新的技术
- 需要现代 API 的项目

---

### 6. SQLite (rusqlite)

#### 基本信息
- **语言**: C 库的 Rust 绑定
- **状态**: 最成熟的嵌入式数据库
- **Rust 绑定**: rusqlite

#### 优势
- ✅ 最成熟
- ✅ SQL 查询支持
- ✅ 极其稳定
- ✅ 单文件部署

#### 劣势
- ❌ SQL 解析开销
- ❌ 对于纯 KV 存储可能过重
- ❌ C 库绑定（但有 bundled 特性）

#### 适用场景
- 需要 SQL 查询的场景
- 需要复杂查询的应用

---

### 7. BonsaiDB

#### 基本信息
- **语言**: 纯 Rust
- **状态**: 实验阶段
- **类型**: NoSQL 数据库

#### 优势
- ✅ 纯 Rust 实现
- ✅ NoSQL 数据库，功能丰富
- ✅ 支持视图、查询等高级功能

#### 劣势
- ❌ 仍处于实验阶段
- ❌ 对于简单 KV 存储可能过重

#### 适用场景
- 需要丰富功能的 NoSQL 数据库
- 愿意使用实验性技术的项目

---

## 性能对比

### 写入性能
RocksDB > redb > sled > LMDB

### 读取性能
LMDB > MDBX > RocksDB > redb > sled

### 稳定性
RocksDB ≈ LMDB > MDBX > redb > sled

### 开发体验
redb > sled > RocksDB > LMDB > MDBX

---

## 针对 GraphDB 的需求分析

GraphDB 项目的特点：
- 单节点图数据库
- 需要高性能读写
- 需要事务支持
- 需要索引支持
- 需要易于部署
- 追求稳定性

---

## 推荐方案

### 🥇 首选：RocksDB (rust-rocksdb)

**理由**：
- 成熟稳定，大量生产环境验证
- 性能优秀，特别是写入密集型场景
- 丰富的配置选项，可以针对图数据库优化
- TiKV 等分布式数据库都在使用

**适用场景**：追求稳定性和性能的生产环境

---

### 🥈 次选：redb

**理由**：
- 纯 Rust 实现，符合项目理念
- 活跃开发，社区支持好
- 现代 API，开发体验好
- 性能表现良好

**适用场景**：希望保持纯 Rust 生态，愿意接受相对较新的技术

---

### 🥉 备选：MDBX (libmdbx-rs)

**理由**：
- 读取性能极佳
- 非常稳定
- 单文件部署

**适用场景**：读密集型图查询场景

---

### ⚠️ 不推荐继续使用 sled

**理由**：
- 长期未达到 1.0.0
- 社区活跃度下降
- 生产环境风险较高

---

## 迁移建议

### 短期
如果项目还在开发阶段，可以继续使用 sled，但要密切关注其状态。

### 中期
考虑迁移到 RocksDB，因为：
- 成熟稳定
- 性能优秀
- 有大量成功案例

### 长期
如果 redb 继续快速发展，可以考虑迁移到 redb，保持纯 Rust 生态。

---

## 下一步

需要使用 Context7 深入查询以下存储库的文档：
1. RocksDB (rust-rocksdb)
2. heed (LMDB)
3. libmdbx-rs (MDBX)
4. redb

然后创建更详细的对比分析文档。

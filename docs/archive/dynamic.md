# 动态分发使用记录

## 文件：src/core/context/runtime.rs

### 保留的动态分发使用

以下动态分发使用是**有意保留**的，因为它们提供了必要的灵活性：

1. **`tag_schema: Option<Arc<dyn SchemaManager>>`**
   - **位置**：第155行
   - **理由**：运行时上下文需要支持不同的schema管理策略，不同的标签可能需要不同的schema管理器实现
   - **设计选择**：这是必要的灵活性设计，允许在运行时动态选择schema管理器

2. **`edge_schema: Option<Arc<dyn SchemaManager>>`**
   - **位置**：第162行
   - **理由**：与tag_schema相同，边schema也需要支持多种管理策略
   - **设计选择**：保持与tag_schema一致的设计模式

### 已优化的动态分发使用

以下动态分发使用已**替换为泛型参数**：

1. **存储环境中的动态分发**（已优化）
   - **原代码**：`storage_engine: Arc<dyn StorageEngine>`
   - **优化后**：`storage_engine: Arc<S>`（使用泛型参数S）
   - **性能提升**：预计10-15%的性能提升

2. **Schema管理器中的动态分发**（已优化）
   - **原代码**：`schema_manager: Arc<dyn SchemaManager>`
   - **优化后**：`schema_manager: Arc<M>`（使用泛型参数M）

3. **索引管理器中的动态分发**（已优化）
   - **原代码**：`index_manager: Arc<dyn IndexManager>`
   - **优化后**：`index_manager: Arc<I>`（使用泛型参数I）

### 默认类型别名

为简化使用，提供了以下默认类型别名：

- `DefaultStorageEnv`：使用`NativeStorage`、`MemorySchemaManager`、`MemoryIndexManager`
- `DefaultPlanContext`：使用默认存储环境
- `DefaultRuntimeContext`：使用默认计划上下文

### 性能影响分析

- **优化部分**：存储环境中的动态分发替换为泛型参数，获得静态分发性能优势
- **保留部分**：运行时上下文中的动态分发是必要的设计权衡，性能影响可控
- **总体效果**：混合策略既获得性能提升，又保持系统灵活性

### 设计原则

1. **性能优先**：在可能的情况下使用泛型参数替代动态分发
2. **灵活性保留**：在需要支持多种实现的情况下保留动态分发
3. **文档记录**：所有保留的动态分发使用必须有明确的理由说明

## 文件：src/query/executor/

### 保留的动态分发使用

以下动态分发使用是**有意保留**的，因为它们提供了必要的灵活性：

1. **`ExecutionSchedule.executors: HashMap<i64, Box<dyn Executor<S>>>`**
   - **位置**：`src/query/scheduler/execution_schedule.rs`
   - **理由**：执行调度器需要在运行时存储和管理多种不同类型的执行器，执行器类型通过 `PlanNodeEnum` 枚举在运行时决定，编译时无法确定具体类型
   - **设计选择**：这是必要的灵活性设计，允许在运行时动态创建和管理执行器

2. **`ExecutorFactory.create_executor()` 返回 `Box<dyn Executor<S>>`**
   - **位置**：`src/query/executor/factory.rs`
   - **理由**：执行器工厂需要根据运行时的计划节点类型创建对应的执行器，无法在编译时确定返回类型
   - **设计选择**：这是必要的多态设计，支持多种执行器类型的统一创建接口

3. **`AsyncScheduler` 使用 `Box<dyn Executor<S>>`**
   - **位置**：`src/query/scheduler/async_scheduler.rs`
   - **理由**：异步调度器需要并行执行多种执行器，需要统一的接口来操作不同类型的执行器
   - **设计选择**：这是必要的统一接口设计，支持执行器的并行调度

### 为什么不能使用泛型替代

尝试使用泛型参数替代动态分发会遇到以下问题：

1. **无法存储多种不同类型的执行器**
   - 泛型参数只能指定一种类型
   - 无法在同一个容器中存储多种执行器

2. **无法满足调度器需求**
   - 调度器需要在运行时动态选择执行器
   - 泛型参数在编译时确定，无法满足需求

3. **类型系统限制**
   - Rust 的类型系统不支持运行时类型信息
   - 无法在运行时确定泛型参数的具体类型

### async-trait 的使用

Executor 模块使用 `async-trait` crate 来实现异步 trait，这是经过详细分析后的决策：

**决策文档**：`docs/archive/executor-async-trait-decision.md`

**主要理由**：
1. **代码简洁性**：无需额外的包装器代码，代码更直观易懂
2. **性能差异可忽略**：async-trait 的性能已经过广泛验证
3. **可维护性高**：社区标准，问题解决方案丰富
4. **风险更低**：成熟的解决方案，社区验证
5. **生态系统兼容性好**：与大多数库兼容，开发者熟悉度高

**详细对比分析**：`docs/archive/async-trait-vs-afit-comparison.md`

### 性能影响分析

- **动态分发开销**：每次执行器调用有 1 次动态分发 + 1 次 Box 分配
- **性能影响**：在查询执行场景中，动态分发的开销相对于实际查询处理逻辑可以忽略不计
- **总体效果**：动态分发提供了必要的灵活性，性能影响可控

### 设计原则

1. **性能优先**：在可能的情况下使用泛型参数替代动态分发
2. **灵活性保留**：在需要支持多种实现的情况下保留动态分发
3. **文档记录**：所有保留的动态分发使用必须有明确的理由说明
4. **实用主义**：选择经过验证的解决方案，而不是盲目追求技术新颖性

## 文件：src/storage/index/memory_index_manager.rs

### 保留的动态分发使用

以下动态分发使用是**有意保留**的，因为它们提供了必要的灵活性：

1. **`storage_engine: Option<Arc<dyn StorageClient>>`**
   - **位置**：第192行
   - **理由**：MemoryIndexManager 需要支持不同的存储引擎实现，以便于测试和灵活部署。在实际使用中，存储引擎类型通常在应用启动时确定，之后不会改变，因此动态分发的运行时开销是可接受的
   - **设计选择**：这是必要的灵活性设计，允许索引管理器与多种存储引擎实现协同工作
   - **性能考虑**：由于存储引擎在初始化后通常不会改变，动态分发的虚函数表查找开销相对于索引查询操作可以忽略不计

2. **`with_storage_engine()` 和 `set_storage_engine()` 方法**
   - **位置**：第226行和第241行
   - **理由**：这些方法提供了设置存储引擎的能力，主要用于测试和依赖注入场景
   - **设计选择**：保持 API 的一致性和可测试性

### 为什么不能使用泛型替代

尝试使用泛型参数替代动态分发会遇到以下问题：

1. **API 兼容性**
   - MemoryIndexManager 作为公开的结构体，如果使用泛型参数会显著增加使用复杂度
   - 大多数调用者只需要存储引擎的功能，不需要关心具体类型

2. **依赖管理**
   - 泛型参数需要在调用链的每一层传递，增加代码复杂度
   - 对于只需要使用索引功能的模块，引入泛型参数是不必要的负担

3. **类型推断困难**
   - 大量使用泛型可能导致类型推断失败，需要显式指定类型参数

### 设计权衡

- **选择动态分发**：保持 API 简洁，降低使用门槛
- **性能影响**：由于存储引擎在初始化后不会改变，动态分发开销极小
- **替代方案**：如果性能成为瓶颈，可以考虑使用泛型参数重构，但这会增加代码复杂度

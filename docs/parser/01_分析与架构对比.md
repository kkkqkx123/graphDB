# nebula-3.8.0 Parser 目录分析与新架构对比

## 1. 原始 nebula-3.8.0 Parser 目录结构分析

### 1.1 目录内容
- **GQLParser.h/cpp**: 主要的查询解析器类，封装了词法分析器和语法分析器
- **parser.yy**: Bison 语法文件，定义了查询语言的语法规则
- **scanner.lex**: Flex 词法分析器文件，定义了词法标记
- **Sentence.h**: 查询语句的基类定义
- **各类语句实现**: 
  - AdminSentences: 管理员语句
  - Clauses: 子句实现
  - MaintainSentences: 维护语句
  - MatchSentence: MATCH 查询句
  - MutateSentences: 变更语句
  - TraverseSentences: 遍历语句
  - UserSentences: 用户管理语句
- **测试目录**: test/ - 包含解析器测试

### 1.2 主要功能组件
- **词法分析器 (GraphScanner)**: 由 Flex 生成，负责将输入的查询字符串转换为词法标记
- **语法分析器 (GraphParser)**: 由 Bison 生成，负责根据语法规则构建抽象语法树(AST)
- **语法树节点 (Sentences)**: 代表各种查询语句和子句的节点类型
- **错误处理**: 语法错误的收集和报告机制

### 1.3 支持的查询类型
- DDL语句: CREATE/DROP SPACE, TAG, EDGE, INDEX
- DML语句: INSERT, UPDATE, DELETE, UPSERT
- 查询语句: GO, MATCH, LOOKUP, FIND PATH, FETCH
- 管理语句: ADMIN, BALANCE, CONFIG, SNAPSHOT
- 用户管理: CREATE/ALTER/DROP USER, GRANT/REVOKE

## 2. 新架构对比

### 2.1 当前新架构状态
- **查询模块**: `src/query/mod.rs` 中存在 `QueryParser` 结构，但只有极简的解析功能
- **查询类型**: 仅支持 CREATE NODE, MATCH, DELETE NODE 等基本操作
- **AST**: 存在 `AstContext` 结构，但没有完整的 AST 节点定义
- **规划器**: 存在 `MatchPlanner`，但注释明确指出缺失解析器部分

### 2.2 架构差异
| 组件 | nebula-3.8.0 | 新架构graphDB |
|------|-------------|---------------|
| 解析器生成工具 | Flex + Bison | 需要手动实现 |
| 词法分析 | Scanner.lex | 需要重新实现 |
| 语法分析 | Parser.yy | 需要重新实现 |
| AST节点 | Sentence类层次 | 需要定义Rust结构 |
| 错误处理 | StatusOr | Result<T, QueryError> |
| 查询支持 | 支持完整的nGQL | 目前仅支持简单查询 |

## 3. 迁移策略

### 3.1 总体策略
1. 保留原解析器的语法规则和功能设计
2. 用Rust重新实现解析器，符合新架构设计
3. 适配简化后的功能集，符合单机图数据库需求
4. 集成到现有的查询执行管道中

### 3.2 技术栈选择
- 词法分析: 手工实现或使用Rust的lexer生成工具(如logos)
- 语法分析: 使用Rust的parser生成工具(如lalrpop)或手工实现
- AST节点: 定义Rust枚举和结构体

### 3.3 实现阶段
1. 分析并提取原解析器的核心语法规则
2. 设计新架构下的AST节点结构
3. 实现词法分析器
4. 实现语法分析器
5. 集成到查询执行管道
6. 测试和验证

## 4. 潜在挑战

1. **语法规则复杂性**: nebula的查询语言语法相当复杂，需要仔细分析和迁移
2. **错误处理**: 从C++的StatusOr模式迁移到Rust的Result模式
3. **性能**: 从C++的Flex/Bison实现迁移到Rust实现，需保持性能
4. **功能裁剪**: 新架构是单机版，需要裁剪分布式相关的语句